{
  "version": 3,
  "sources": ["../../jotai-history/src/actions.ts", "../../jotai-history/src/withHistory.ts", "../../jotai-history/src/withUndo.ts", "../../jotai-history/src/withUndoableHistory.ts"],
  "sourcesContent": ["export const UNDO = Symbol('undo')\nexport type UNDO = typeof UNDO\n\nexport const REDO = Symbol('redo')\nexport type REDO = typeof REDO\n\nexport const RESET = Symbol('reset')\nexport type RESET = typeof RESET\n", "import type { Atom, WritableAtom } from 'jotai'\nimport { atom } from 'jotai/vanilla'\nimport { RESET } from './actions'\n\nexport type History<Value> = Value[]\n\n/**\n * @param targetAtom an atom or derived atom\n * @param limit the maximum number of history states to keep\n * @returns an atom with an array of history states\n */\nexport function withHistory<Value>(\n  targetAtom: Atom<Value>,\n  limit: number\n): WritableAtom<History<Value>, [RESET], void> {\n  const refreshAtom = atom(0)\n  refreshAtom.debugPrivate = true\n  const historyAtom = {\n    read: (get) => (get(refreshAtom), { history: [] }),\n    write: (get, set) => {\n      get(historyAtom).history.length = 0\n      set(refreshAtom, (v) => v + 1)\n    },\n    onMount: (reset) => reset,\n    debugPrivate: true,\n    init: 1, // dirty hack to bypass hasInitialValue\n  } as WritableAtom<{ history: Value[] }, [], void>\n  return atom(\n    (get) => {\n      const ref = get(historyAtom)\n      return (ref.history = [get(targetAtom), ...ref.history].slice(0, limit))\n    },\n    (_, set, action: RESET) => {\n      if (action === RESET) {\n        set(historyAtom)\n      }\n    }\n  )\n}\n", "import type { WritableAtom } from 'jotai/vanilla'\nimport { atom } from 'jotai/vanilla'\nimport { REDO, RESET, UNDO } from './actions'\nimport type { withHistory } from './withHistory'\n\nexport type Indicators = {\n  canUndo: boolean\n  canRedo: boolean\n}\n\n/**\n * @param targetAtom a primitive atom or equivalent\n * @param limit the maximum number of history states to keep\n * @returns an atom with undo/redo capabilities\n */\nexport function withUndo<Value, Args extends unknown[], Result>(\n  historyAtom: ReturnType<typeof withHistory>,\n  targetAtom: WritableAtom<Value, Args, Result>,\n  limit: number,\n  getArgs?: (value: Value) => Args\n): WritableAtom<Indicators, [UNDO | REDO | RESET], void> {\n  const createRef = () => ({\n    index: 0,\n    stack: [] as Value[],\n    action: null as UNDO | REDO | RESET | null,\n  })\n  const refreshAtom = atom(0)\n  const refAtom = atom(createRef, (get, set, action: RESET) => {\n    if (action === RESET) {\n      void Object.assign(get(refAtom), createRef())\n      set(refreshAtom, (v) => v + 1)\n    }\n  })\n  refAtom.onMount = (setAtom) => () => setAtom(RESET)\n  refAtom.debugPrivate = true\n  const updateRefAtom = atom(\n    (get) => {\n      const history = get(historyAtom)\n      const ref = get(refAtom)\n      get(refreshAtom)\n      if (ref.action) {\n        // recalculation caused by undo/redo/reset\n        ref.action = null\n      } else {\n        // Remove future states if any\n        ref.stack = ref.stack.slice(0, ref.index + 1)\n        // Push the current state to the stack\n        ref.stack.push(history[0] as Value)\n        // Limit the stack\n        ref.stack = ref.stack.slice(-limit)\n        // Move the current index to the end\n        ref.index = ref.stack.length - 1\n      }\n      return { ...ref }\n    },\n    (get, set) => {\n      const ref = get(refAtom)\n      ref.stack = [get(targetAtom)]\n      return () => set(refAtom, RESET)\n    }\n  )\n  updateRefAtom.onMount = (mount) => mount()\n  updateRefAtom.debugPrivate = true\n  const canUndoAtom = atom((get) => {\n    return get(updateRefAtom).index > 0\n  })\n  const canRedoAtom = atom((get) => {\n    const ref = get(updateRefAtom)\n    return ref.index < ref.stack.length - 1\n  })\n  return atom<Indicators, [UNDO | REDO | RESET], void>(\n    (get) => ({\n      canUndo: get(canUndoAtom),\n      canRedo: get(canRedoAtom),\n    }),\n    (get, set, action) => {\n      const ref = get(refAtom)\n      const setCurrentState = (index: number) => {\n        if (index in ref.stack) {\n          const value = ref.stack[index]!\n          const args = typeof getArgs === 'function' ? getArgs(value) : [value]\n          set(targetAtom, ...(args as Args))\n        }\n      }\n      if (action === UNDO) {\n        if (get(canUndoAtom)) {\n          ref.action = UNDO\n          get(historyAtom).shift()\n          setCurrentState(--ref.index)\n          get(historyAtom).shift()\n        }\n      } else if (action === REDO) {\n        if (get(canRedoAtom)) {\n          ref.action = REDO\n          setCurrentState(++ref.index)\n        }\n      } else if (action === RESET) {\n        ref.action = RESET\n        set(refAtom, action)\n      } else {\n        return\n      }\n      set(refreshAtom, (v) => v + 1)\n    }\n  )\n}\n", "import type {\n  Atom,\n  ExtractAtomArgs,\n  ExtractAtomResult,\n  ExtractAtomValue,\n  WritableAtom,\n} from 'jotai/vanilla'\nimport { atom } from 'jotai/vanilla'\nimport { REDO, RESET, UNDO } from './actions'\nimport { type History, withHistory } from './withHistory'\nimport { type Indicators, withUndo } from './withUndo'\n\ntype WithUndoableHistory<T extends Atom<unknown>> =\n  T extends WritableAtom<any, any[], any>\n    ? WritableAtom<\n        History<ExtractAtomValue<T>> & Indicators,\n        ExtractAtomArgs<T> | [RESET | UNDO | REDO],\n        ExtractAtomResult<T> | void\n      >\n    : WritableAtom<History<ExtractAtomValue<T>>, [RESET], void>\n\nexport function withUndoableHistory<T extends Atom<unknown>>(\n  targetAtom: T,\n  limit: number\n): WithUndoableHistory<T> {\n  const historyAtom = withPrivate(withHistory(targetAtom, limit))\n  let undoAtom: ReturnType<typeof withUndo> | undefined\n  if (isWritableAtom(targetAtom)) {\n    // eslint-disable-next-line prefer-rest-params\n    const getArgs = arguments[2] ?? Array.of\n    undoAtom = withPrivate(withUndo(historyAtom, targetAtom, limit, getArgs))\n  }\n  return atom(\n    (get) =>\n      Object.assign(\n        get(historyAtom),\n        isWritableAtom(targetAtom) ? get(undoAtom!) : {}\n      ),\n    (_, set, ...args: unknown[]) => {\n      const [action] = args\n      if (action === RESET) {\n        set(historyAtom, action)\n        if (undoAtom) {\n          set(undoAtom, action)\n        }\n      } else if (!isWritableAtom(targetAtom)) {\n        return\n      } else if (action === UNDO || action === REDO) {\n        set(undoAtom!, action)\n      } else {\n        return set(targetAtom, ...args)\n      }\n    }\n  ) as WithUndoableHistory<T>\n}\n\ntype InferWritableAtom<T extends Atom<unknown>> =\n  T extends WritableAtom<infer Value, infer Args, infer Result>\n    ? WritableAtom<Value, Args, Result>\n    : never\n\nfunction isWritableAtom<T extends Atom<unknown>>(\n  atom: T\n): atom is T & InferWritableAtom<T> {\n  return 'write' in atom\n}\n\nfunction withPrivate<T extends Atom<unknown>>(atom: T) {\n  atom.debugPrivate = true\n  return atom\n}\n"],
  "mappings": "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",
  "names": ["atom"]
}
