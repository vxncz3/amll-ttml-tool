{
  "version": 3,
  "sources": ["../../react-viewport-list/lib/index.js"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ViewportList = void 0;\nconst jsx_runtime_1 = require(\"react/jsx-runtime\");\nconst react_1 = require(\"react\");\nconst IS_SSR = typeof window === 'undefined';\nconst IS_TOUCH_DEVICE = !IS_SSR &&\n    (() => {\n        try {\n            return 'ontouchstart' in window || navigator.maxTouchPoints;\n        }\n        catch (_a) {\n            return false;\n        }\n    })();\nconst IS_OVERFLOW_ANCHOR_SUPPORTED = !IS_SSR &&\n    (() => {\n        try {\n            return window.CSS.supports('overflow-anchor: auto');\n        }\n        catch (_a) {\n            return false;\n        }\n    })();\nconst SHOULD_DELAY_SCROLL = IS_TOUCH_DEVICE && !IS_OVERFLOW_ANCHOR_SUPPORTED;\nconst PROP_NAME_FOR_Y_AXIS = {\n    top: 'top',\n    bottom: 'bottom',\n    clientHeight: 'clientHeight',\n    scrollHeight: 'scrollHeight',\n    scrollTop: 'scrollTop',\n    overflowY: 'overflowY',\n    height: 'height',\n    minHeight: 'minHeight',\n    maxHeight: 'maxHeight',\n    marginTop: 'marginTop',\n};\nconst PROP_NAME_FOR_X_AXIS = {\n    top: 'left',\n    bottom: 'right',\n    scrollHeight: 'scrollWidth',\n    clientHeight: 'clientWidth',\n    scrollTop: 'scrollLeft',\n    overflowY: 'overflowX',\n    minHeight: 'minWidth',\n    height: 'width',\n    maxHeight: 'maxWidth',\n    marginTop: 'marginLeft',\n};\nconst normalizeValue = (min, value, max = Infinity) => Math.max(Math.min(value, max), min);\nconst getDiff = (value1, value2, step) => Math.ceil(Math.abs(value1 - value2) / step);\nconst useIsomorphicLayoutEffect = IS_SSR ? react_1.useEffect : react_1.useLayoutEffect;\nconst generateArray = (from, to, generate) => {\n    const array = [];\n    for (let index = from; index < to; index++) {\n        array.push(generate(index));\n    }\n    return array;\n};\nconst findElement = ({ fromElement, toElement, fromIndex, asc = true, compare, }) => {\n    let index = fromIndex;\n    let element = fromElement;\n    while (element && element !== toElement) {\n        if (compare(element, index)) {\n            return [element, index];\n        }\n        if (asc) {\n            index++;\n            element = element.nextSibling;\n        }\n        else {\n            index--;\n            element = element.previousSibling;\n        }\n    }\n    return [null, -1];\n};\nconst SCROLLABLE_REGEXP = /auto|scroll/gi;\nconst findNearestScrollableElement = (propName, node) => {\n    if (!node || node === document.body || node === document.documentElement) {\n        return document.documentElement;\n    }\n    const style = window.getComputedStyle(node);\n    if (SCROLLABLE_REGEXP.test(style[propName.overflowY]) || SCROLLABLE_REGEXP.test(style.overflow)) {\n        return node;\n    }\n    return findNearestScrollableElement(propName, node.parentNode);\n};\nconst getStyle = (propName, size, marginTop = 0) => ({\n    padding: 0,\n    margin: 0,\n    border: 'none',\n    visibility: 'hidden',\n    overflowAnchor: 'none',\n    [propName.minHeight]: size,\n    [propName.height]: size,\n    [propName.maxHeight]: size,\n    [propName.marginTop]: marginTop,\n});\nconst ViewportListInner = ({ items = [], count, children, viewportRef, itemSize = 0, itemMargin = -1, overscan = 1, axis = 'y', initialIndex = -1, initialAlignToTop = true, initialOffset = 0, initialDelay = -1, initialPrerender = 0, onViewportIndexesChange, overflowAnchor = 'auto', withCache = true, scrollThreshold = 0, renderSpacer = ({ ref, style }) => (0, jsx_runtime_1.jsx)(\"div\", { ref: ref, style: style }), indexesShift = 0, getItemBoundingClientRect = (element) => element.getBoundingClientRect(), }, ref) => {\n    const propName = axis === 'y' ? PROP_NAME_FOR_Y_AXIS : PROP_NAME_FOR_X_AXIS;\n    const withCount = typeof count === 'number';\n    const maxIndex = (withCount ? count : items.length) - 1;\n    const [[estimatedItemHeight, estimatedItemMargin], setItemDimensions] = (0, react_1.useState)(() => [\n        normalizeValue(0, itemSize),\n        normalizeValue(-1, itemMargin),\n    ]);\n    const itemHeightWithMargin = normalizeValue(0, estimatedItemHeight + estimatedItemMargin);\n    const overscanSize = normalizeValue(0, Math.ceil(overscan * itemHeightWithMargin));\n    const [indexes, setIndexes] = (0, react_1.useState)([initialIndex - initialPrerender, initialIndex + initialPrerender]);\n    const anchorElementRef = (0, react_1.useRef)(null);\n    const anchorIndexRef = (0, react_1.useRef)(-1);\n    const topSpacerRef = (0, react_1.useRef)(null);\n    const bottomSpacerRef = (0, react_1.useRef)(null);\n    const ignoreOverflowAnchorRef = (0, react_1.useRef)(false);\n    const lastIndexesShiftRef = (0, react_1.useRef)(indexesShift);\n    const cacheRef = (0, react_1.useRef)([]);\n    const scrollToIndexOptionsRef = (0, react_1.useRef)(initialIndex >= 0\n        ? {\n            index: initialIndex,\n            alignToTop: initialAlignToTop,\n            offset: initialOffset,\n            delay: initialDelay,\n            prerender: initialPrerender,\n        }\n        : null);\n    const scrollToIndexTimeoutIdRef = (0, react_1.useRef)(null);\n    const marginTopRef = (0, react_1.useRef)(0);\n    const viewportIndexesRef = (0, react_1.useRef)([-1, -1]);\n    const scrollTopRef = (0, react_1.useRef)(null);\n    const [startIndex, endIndex] = (0, react_1.useMemo)(() => {\n        indexes[0] = normalizeValue(0, indexes[0], maxIndex);\n        indexes[1] = normalizeValue(indexes[0], indexes[1], maxIndex);\n        const shift = indexesShift - lastIndexesShiftRef.current;\n        lastIndexesShiftRef.current = indexesShift;\n        const topSpacer = topSpacerRef.current;\n        if (topSpacer && shift) {\n            indexes[0] = normalizeValue(0, indexes[0] + shift, maxIndex);\n            indexes[1] = normalizeValue(indexes[0], indexes[1] + shift, maxIndex);\n            anchorElementRef.current = topSpacer.nextSibling;\n            anchorIndexRef.current = indexes[0];\n            ignoreOverflowAnchorRef.current = true;\n        }\n        return indexes;\n    }, [indexesShift, indexes, maxIndex]);\n    const topSpacerStyle = (0, react_1.useMemo)(() => getStyle(propName, (withCache ? cacheRef.current : [])\n        .slice(0, startIndex)\n        .reduce((sum, next) => sum + (next - estimatedItemHeight), startIndex * itemHeightWithMargin), marginTopRef.current), [propName, withCache, startIndex, itemHeightWithMargin, estimatedItemHeight]);\n    const bottomSpacerStyle = (0, react_1.useMemo)(() => getStyle(propName, (withCache ? cacheRef.current : [])\n        .slice(endIndex + 1, maxIndex + 1)\n        .reduce((sum, next) => sum + (next - estimatedItemHeight), itemHeightWithMargin * (maxIndex - endIndex))), [propName, withCache, endIndex, maxIndex, itemHeightWithMargin, estimatedItemHeight]);\n    const getViewport = (0, react_1.useMemo)(() => {\n        let autoViewport = null;\n        return () => {\n            if (viewportRef) {\n                if (viewportRef.current === document.body) {\n                    return document.documentElement;\n                }\n                return viewportRef.current;\n            }\n            if (autoViewport && autoViewport.isConnected) {\n                return autoViewport;\n            }\n            const topSpacer = topSpacerRef.current;\n            if (!topSpacer) {\n                return null;\n            }\n            autoViewport = findNearestScrollableElement(propName, topSpacer.parentNode);\n            return autoViewport;\n        };\n    }, [propName, viewportRef]);\n    const mainFrameRef = (0, react_1.useRef)(() => { });\n    const getScrollPositionRef = (0, react_1.useRef)(() => ({ index: -1, offset: 0 }));\n    useIsomorphicLayoutEffect(() => {\n        mainFrameRef.current = () => {\n            const viewport = getViewport();\n            const topSpacer = topSpacerRef.current;\n            const bottomSpacer = bottomSpacerRef.current;\n            if (!viewport || !topSpacer || !bottomSpacer) {\n                return;\n            }\n            const topElement = topSpacer.nextSibling;\n            const bottomElement = bottomSpacer.previousSibling;\n            const viewportRect = viewport.getBoundingClientRect();\n            const topSpacerRect = topSpacer.getBoundingClientRect();\n            const bottomSpacerRect = bottomSpacer.getBoundingClientRect();\n            const limits = {\n                [propName.top]: viewport === document.documentElement ? 0 : viewportRect[propName.top],\n                [propName.bottom]: viewport === document.documentElement\n                    ? document.documentElement[propName.clientHeight]\n                    : viewportRect[propName.bottom],\n            };\n            const limitsWithOverscanSize = {\n                [propName.top]: limits[propName.top] - overscanSize,\n                [propName.bottom]: limits[propName.bottom] + overscanSize,\n            };\n            if ((marginTopRef.current < 0 &&\n                topSpacerRect[propName.top] - marginTopRef.current >= limitsWithOverscanSize[propName.top]) ||\n                (marginTopRef.current > 0 && topSpacerRect[propName.top] >= limitsWithOverscanSize[propName.top]) ||\n                (marginTopRef.current && scrollToIndexOptionsRef.current)) {\n                topSpacer.style[propName.marginTop] = '0px';\n                viewport.style[propName.overflowY] = 'hidden';\n                viewport[propName.scrollTop] += -marginTopRef.current;\n                viewport.style[propName.overflowY] = '';\n                marginTopRef.current = 0;\n                return;\n            }\n            if (estimatedItemHeight === 0 || estimatedItemMargin === -1) {\n                let itemsHeightSum = 0;\n                findElement({\n                    fromElement: topElement,\n                    toElement: bottomSpacer,\n                    fromIndex: startIndex,\n                    compare: (element) => {\n                        itemsHeightSum += getItemBoundingClientRect(element)[propName.height];\n                        return false;\n                    },\n                });\n                if (!itemsHeightSum) {\n                    return;\n                }\n                const renderedItemsCount = endIndex - startIndex + 1;\n                const nextItemHeight = estimatedItemHeight === 0 ? Math.ceil(itemsHeightSum / renderedItemsCount) : estimatedItemHeight;\n                const nextItemMargin = estimatedItemMargin === -1\n                    ? Math.ceil((bottomSpacerRect[propName.top] - topSpacerRect[propName.bottom] - itemsHeightSum) /\n                        renderedItemsCount)\n                    : estimatedItemMargin;\n                setItemDimensions([nextItemHeight, nextItemMargin]);\n                return;\n            }\n            if (scrollToIndexTimeoutIdRef.current) {\n                return;\n            }\n            if (scrollToIndexOptionsRef.current) {\n                const targetIndex = normalizeValue(0, scrollToIndexOptionsRef.current.index, maxIndex);\n                if (targetIndex < startIndex || targetIndex > endIndex) {\n                    setIndexes([\n                        targetIndex - scrollToIndexOptionsRef.current.prerender,\n                        targetIndex + scrollToIndexOptionsRef.current.prerender,\n                    ]);\n                    return;\n                }\n                const [targetElement] = findElement({\n                    fromElement: topElement,\n                    toElement: bottomSpacer,\n                    fromIndex: startIndex,\n                    compare: (_, index) => index === targetIndex,\n                });\n                if (!targetElement) {\n                    return;\n                }\n                const { alignToTop, offset, delay } = scrollToIndexOptionsRef.current;\n                scrollToIndexOptionsRef.current = null;\n                const scrollToElement = () => {\n                    const elementRect = getItemBoundingClientRect(targetElement);\n                    const shift = alignToTop\n                        ? elementRect[propName.top] - limits[propName.top] + offset\n                        : elementRect[propName.bottom] -\n                            limits[propName.top] -\n                            viewport[propName.clientHeight] +\n                            offset;\n                    viewport[propName.scrollTop] += shift;\n                    scrollToIndexTimeoutIdRef.current = null;\n                };\n                const scrollToElementDelay = delay < 0 && SHOULD_DELAY_SCROLL ? 30 : delay;\n                if (scrollToElementDelay > 0) {\n                    scrollToIndexTimeoutIdRef.current = setTimeout(scrollToElement, scrollToElementDelay);\n                    return;\n                }\n                scrollToElement();\n                return;\n            }\n            if (scrollTopRef.current === null) {\n                scrollTopRef.current = viewport.scrollTop;\n            }\n            else if (scrollTopRef.current !== viewport.scrollTop) {\n                const diff = Math.abs(viewport.scrollTop - scrollTopRef.current);\n                scrollTopRef.current = viewport.scrollTop;\n                if (scrollThreshold > 0 && diff > scrollThreshold) {\n                    return;\n                }\n            }\n            const topSecondElement = topElement === bottomSpacer ? bottomSpacer : topElement.nextSibling;\n            const bottomSecondElement = bottomElement === topSpacer ? topSpacer : bottomElement.previousSibling;\n            const averageSize = Math.ceil((bottomSpacerRect[propName.top] - topSpacerRect[propName.bottom]) / (endIndex + 1 - startIndex));\n            const isAllAboveTop = topSpacerRect[propName.bottom] > limitsWithOverscanSize[propName.bottom];\n            const isAllBelowBottom = bottomSpacerRect[propName.top] < limitsWithOverscanSize[propName.top];\n            const isTopBelowTop = !isAllAboveTop &&\n                !isAllBelowBottom &&\n                topSpacerRect[propName.bottom] > limitsWithOverscanSize[propName.top];\n            const isBottomAboveBottom = !isAllAboveTop &&\n                !isAllBelowBottom &&\n                bottomSpacerRect[propName.top] < limitsWithOverscanSize[propName.bottom];\n            const isBottomSecondAboveTop = !isAllAboveTop &&\n                !isAllBelowBottom &&\n                (bottomSecondElement === topSpacer ? topSpacerRect : getItemBoundingClientRect(bottomSecondElement))[propName.bottom] > limitsWithOverscanSize[propName.bottom];\n            const isTopSecondAboveTop = !isAllAboveTop &&\n                !isAllBelowBottom &&\n                (topSecondElement === bottomSpacer ? bottomSpacerRect : getItemBoundingClientRect(topSecondElement))[propName.top] < limitsWithOverscanSize[propName.top];\n            let nextStartIndex = startIndex;\n            let nextEndIndex = endIndex;\n            if (isAllAboveTop) {\n                nextStartIndex -= getDiff(topSpacerRect[propName.bottom], limitsWithOverscanSize[propName.top], averageSize);\n                nextEndIndex -= getDiff(bottomSpacerRect[propName.top], limitsWithOverscanSize[propName.bottom], averageSize);\n            }\n            if (isAllBelowBottom) {\n                nextEndIndex += getDiff(bottomSpacerRect[propName.top], limitsWithOverscanSize[propName.bottom], averageSize);\n                nextStartIndex += getDiff(topSpacerRect[propName.bottom], limitsWithOverscanSize[propName.top], averageSize);\n            }\n            if (isTopBelowTop) {\n                nextStartIndex -= getDiff(topSpacerRect[propName.bottom], limitsWithOverscanSize[propName.top], averageSize);\n            }\n            if (isBottomAboveBottom) {\n                nextEndIndex += getDiff(bottomSpacerRect[propName.top], limitsWithOverscanSize[propName.bottom], averageSize);\n            }\n            if (isBottomSecondAboveTop) {\n                const [, index] = findElement({\n                    fromElement: bottomElement,\n                    toElement: topSpacer,\n                    fromIndex: endIndex,\n                    asc: false,\n                    compare: (element) => getItemBoundingClientRect(element)[propName.bottom] <= limitsWithOverscanSize[propName.bottom],\n                });\n                if (index !== -1) {\n                    nextEndIndex = index + 1;\n                }\n            }\n            if (isTopSecondAboveTop) {\n                const [, index] = findElement({\n                    fromElement: topElement,\n                    toElement: bottomSpacer,\n                    fromIndex: startIndex,\n                    compare: (element) => getItemBoundingClientRect(element)[propName.top] >= limitsWithOverscanSize[propName.top],\n                });\n                if (index !== -1) {\n                    nextStartIndex = index - 1;\n                }\n            }\n            if (onViewportIndexesChange) {\n                let [, startViewportIndex] = findElement({\n                    fromElement: topElement,\n                    toElement: bottomSpacer,\n                    fromIndex: startIndex,\n                    compare: (element) => getItemBoundingClientRect(element)[propName.bottom] > limits[propName.top],\n                });\n                if (startViewportIndex === -1) {\n                    startViewportIndex = startIndex;\n                }\n                let [, endViewportIndex] = findElement({\n                    fromElement: bottomElement,\n                    toElement: topSpacer,\n                    fromIndex: endIndex,\n                    asc: false,\n                    compare: (element) => getItemBoundingClientRect(element)[propName.top] < limits[propName.bottom],\n                });\n                if (endViewportIndex === -1) {\n                    endViewportIndex = endIndex;\n                }\n                if (startViewportIndex !== viewportIndexesRef.current[0] ||\n                    endViewportIndex !== viewportIndexesRef.current[1]) {\n                    viewportIndexesRef.current = [startViewportIndex, endViewportIndex];\n                    onViewportIndexesChange(viewportIndexesRef.current);\n                }\n            }\n            nextStartIndex = normalizeValue(0, nextStartIndex, maxIndex);\n            nextEndIndex = normalizeValue(nextStartIndex, nextEndIndex, maxIndex);\n            if (nextStartIndex === startIndex && nextEndIndex === endIndex) {\n                return;\n            }\n            if (nextStartIndex !== startIndex) {\n                if (startIndex >= nextStartIndex) {\n                    anchorElementRef.current = topElement;\n                    anchorIndexRef.current = startIndex;\n                }\n                else {\n                    const [anchorElement, anchorElementIndex] = findElement({\n                        fromElement: topElement,\n                        toElement: bottomSpacer,\n                        fromIndex: startIndex,\n                        compare: (element, index) => {\n                            if (index === nextStartIndex) {\n                                return true;\n                            }\n                            const elementRect = getItemBoundingClientRect(element);\n                            if (elementRect[propName.height] !== estimatedItemHeight) {\n                                cacheRef.current[index] = elementRect[propName.height];\n                            }\n                            return false;\n                        },\n                    });\n                    if (anchorElement) {\n                        anchorElementRef.current = anchorElement;\n                        anchorIndexRef.current = anchorElementIndex;\n                    }\n                    else {\n                        anchorElementRef.current = bottomElement;\n                        anchorIndexRef.current = endIndex;\n                    }\n                }\n            }\n            setIndexes([nextStartIndex, nextEndIndex]);\n        };\n        getScrollPositionRef.current = () => {\n            const viewport = getViewport();\n            const topSpacer = topSpacerRef.current;\n            const bottomSpacer = bottomSpacerRef.current;\n            let scrollIndex = -1;\n            let scrollOffset = 0;\n            if (!viewport || !topSpacer || !bottomSpacer) {\n                return { index: scrollIndex, offset: scrollOffset };\n            }\n            const topElement = topSpacer.nextSibling;\n            const viewportRect = viewport.getBoundingClientRect();\n            const limits = {\n                [propName.top]: viewport === document.documentElement ? 0 : viewportRect[propName.top],\n                [propName.bottom]: viewport === document.documentElement\n                    ? document.documentElement[propName.clientHeight]\n                    : viewportRect[propName.bottom],\n            };\n            findElement({\n                fromElement: topElement,\n                toElement: bottomSpacer,\n                fromIndex: startIndex,\n                compare: (element, index) => {\n                    const rect = getItemBoundingClientRect(element);\n                    scrollIndex = index;\n                    scrollOffset = limits[propName.top] - rect[propName.top];\n                    return rect[propName.bottom] > limits[propName.top];\n                },\n            });\n            return { index: scrollIndex, offset: scrollOffset };\n        };\n    });\n    let anchorHeightOnRender;\n    if (anchorElementRef.current && getViewport() && topSpacerRef.current) {\n        anchorHeightOnRender =\n            getItemBoundingClientRect(anchorElementRef.current)[propName.top] -\n                (getViewport() === document.documentElement ? 0 : getViewport().getBoundingClientRect()[propName.top]);\n    }\n    useIsomorphicLayoutEffect(() => {\n        anchorElementRef.current = null;\n        const anchorIndex = anchorIndexRef.current;\n        const ignoreOverflowAnchor = ignoreOverflowAnchorRef.current;\n        anchorIndexRef.current = -1;\n        ignoreOverflowAnchorRef.current = false;\n        const viewport = getViewport();\n        const topSpacer = topSpacerRef.current;\n        const bottomSpacer = bottomSpacerRef.current;\n        if (anchorIndex === -1 ||\n            !viewport ||\n            !topSpacer ||\n            !bottomSpacer ||\n            anchorHeightOnRender === undefined ||\n            (IS_OVERFLOW_ANCHOR_SUPPORTED && overflowAnchor !== 'none' && !ignoreOverflowAnchor)) {\n            return;\n        }\n        let top = null;\n        if (anchorIndex >= startIndex && anchorIndex <= endIndex) {\n            const [anchorElement] = findElement({\n                fromElement: topSpacer.nextSibling,\n                toElement: bottomSpacer,\n                fromIndex: startIndex,\n                compare: (_, index) => index === anchorIndex,\n            });\n            if (anchorElement) {\n                top = getItemBoundingClientRect(anchorElement)[propName.top];\n            }\n        }\n        else {\n            if (anchorIndex < startIndex) {\n                top =\n                    topSpacer.getBoundingClientRect()[propName.top] +\n                        (withCache ? cacheRef.current : [])\n                            .slice(0, anchorIndex)\n                            .reduce((sum, next) => sum + (next - estimatedItemHeight), anchorIndex * itemHeightWithMargin);\n            }\n            else if (anchorIndex <= maxIndex) {\n                top =\n                    bottomSpacer.getBoundingClientRect()[propName.top] +\n                        (withCache ? cacheRef.current : [])\n                            .slice(endIndex + 1, anchorIndex)\n                            .reduce((sum, next) => sum + (next - estimatedItemHeight), itemHeightWithMargin * (anchorIndex - 1 - endIndex));\n            }\n        }\n        if (top === null) {\n            return;\n        }\n        const offset = top -\n            (viewport === document.documentElement ? 0 : viewport.getBoundingClientRect()[propName.top]) -\n            anchorHeightOnRender;\n        if (!offset) {\n            return;\n        }\n        if (IS_TOUCH_DEVICE) {\n            marginTopRef.current -= offset;\n            topSpacer.style[propName.marginTop] = `${marginTopRef.current}px`;\n            return;\n        }\n        viewport[propName.scrollTop] += offset;\n    }, [startIndex]);\n    useIsomorphicLayoutEffect(() => {\n        let frameId;\n        const frame = () => {\n            frameId = requestAnimationFrame(frame);\n            mainFrameRef.current();\n        };\n        frame();\n        return () => {\n            cancelAnimationFrame(frameId);\n            if (scrollToIndexTimeoutIdRef.current) {\n                clearTimeout(scrollToIndexTimeoutIdRef.current);\n            }\n        };\n    }, []);\n    (0, react_1.useImperativeHandle)(ref, () => ({\n        scrollToIndex: ({ index = -1, alignToTop = true, offset = 0, delay = -1, prerender = 0 }) => {\n            scrollToIndexOptionsRef.current = { index, alignToTop, offset, delay, prerender };\n            mainFrameRef.current();\n        },\n        getScrollPosition: () => getScrollPositionRef.current(),\n    }), []);\n    return ((0, jsx_runtime_1.jsxs)(react_1.Fragment, { children: [renderSpacer({ ref: topSpacerRef, style: topSpacerStyle, type: 'top' }), (!!count || !!items.length) &&\n                generateArray(startIndex, endIndex + 1, withCount ? children : (index) => children(items[index], index, items)), renderSpacer({ ref: bottomSpacerRef, style: bottomSpacerStyle, type: 'bottom' })] }));\n};\nexports.ViewportList = (0, react_1.forwardRef)(ViewportListInner);\n"],
  "mappings": "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",
  "names": ["ref"]
}
