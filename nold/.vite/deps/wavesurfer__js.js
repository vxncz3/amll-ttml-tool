import "./chunk-G3PMV62Z.js";

// node_modules/wavesurfer.js/dist/wavesurfer.esm.js
function t(t2, e2, i2, n2) {
  return new (i2 || (i2 = Promise))((function(s2, r2) {
    function o2(t3) {
      try {
        l2(n2.next(t3));
      } catch (t4) {
        r2(t4);
      }
    }
    function a2(t3) {
      try {
        l2(n2.throw(t3));
      } catch (t4) {
        r2(t4);
      }
    }
    function l2(t3) {
      var e3;
      t3.done ? s2(t3.value) : (e3 = t3.value, e3 instanceof i2 ? e3 : new i2((function(t4) {
        t4(e3);
      }))).then(o2, a2);
    }
    l2((n2 = n2.apply(t2, e2 || [])).next());
  }));
}
var e = class {
  constructor() {
    this.listeners = {};
  }
  on(t2, e2, i2) {
    if (this.listeners[t2] || (this.listeners[t2] = /* @__PURE__ */ new Set()), null == i2 ? void 0 : i2.once) {
      const i3 = (...n2) => {
        this.un(t2, i3), e2(...n2);
      };
      return this.listeners[t2].add(i3), () => this.un(t2, i3);
    }
    return this.listeners[t2].add(e2), () => this.un(t2, e2);
  }
  un(t2, e2) {
    var i2;
    null === (i2 = this.listeners[t2]) || void 0 === i2 || i2.delete(e2);
  }
  once(t2, e2) {
    return this.on(t2, e2, { once: true });
  }
  unAll() {
    this.listeners = {};
  }
  emit(t2, ...e2) {
    this.listeners[t2] && this.listeners[t2].forEach(((t3) => t3(...e2)));
  }
};
var i = { decode: function(e2, i2) {
  return t(this, void 0, void 0, (function* () {
    const t2 = new AudioContext({ sampleRate: i2 });
    try {
      return yield t2.decodeAudioData(e2);
    } finally {
      t2.close();
    }
  }));
}, createBuffer: function(t2, e2) {
  if (!t2 || 0 === t2.length) throw new Error("channelData must be a non-empty array");
  if (e2 <= 0) throw new Error("duration must be greater than 0");
  if ("number" == typeof t2[0] && (t2 = [t2]), !t2[0] || 0 === t2[0].length) throw new Error("channelData must contain non-empty channel arrays");
  !(function(t3) {
    const e3 = t3[0];
    if (e3.some(((t4) => t4 > 1 || t4 < -1))) {
      const i3 = e3.length;
      let n2 = 0;
      for (let t4 = 0; t4 < i3; t4++) {
        const i4 = Math.abs(e3[t4]);
        i4 > n2 && (n2 = i4);
      }
      for (const e4 of t3) for (let t4 = 0; t4 < i3; t4++) e4[t4] /= n2;
    }
  })(t2);
  const i2 = t2.map(((t3) => t3 instanceof Float32Array ? t3 : Float32Array.from(t3)));
  return { duration: e2, length: i2[0].length, sampleRate: i2[0].length / e2, numberOfChannels: i2.length, getChannelData: (t3) => {
    const e3 = i2[t3];
    if (!e3) throw new Error(`Channel ${t3} not found`);
    return e3;
  }, copyFromChannel: AudioBuffer.prototype.copyFromChannel, copyToChannel: AudioBuffer.prototype.copyToChannel };
} };
function n(t2, e2) {
  const i2 = e2.xmlns ? document.createElementNS(e2.xmlns, t2) : document.createElement(t2);
  for (const [t3, s2] of Object.entries(e2)) if ("children" === t3 && s2) for (const [t4, e3] of Object.entries(s2)) e3 instanceof Node ? i2.appendChild(e3) : "string" == typeof e3 ? i2.appendChild(document.createTextNode(e3)) : i2.appendChild(n(t4, e3));
  else "style" === t3 ? Object.assign(i2.style, s2) : "textContent" === t3 ? i2.textContent = s2 : i2.setAttribute(t3, s2.toString());
  return i2;
}
function s(t2, e2, i2) {
  const s2 = n(t2, e2 || {});
  return null == i2 || i2.appendChild(s2), s2;
}
var r = Object.freeze({ __proto__: null, createElement: s, default: s });
var o = { fetchBlob: function(e2, i2, n2) {
  return t(this, void 0, void 0, (function* () {
    const s2 = yield fetch(e2, n2);
    if (s2.status >= 400) throw new Error(`Failed to fetch ${e2}: ${s2.status} (${s2.statusText})`);
    return (function(e3, i3) {
      t(this, void 0, void 0, (function* () {
        if (!e3.body || !e3.headers) return;
        const t2 = e3.body.getReader(), n3 = Number(e3.headers.get("Content-Length")) || 0;
        let s3 = 0;
        const r2 = (t3) => {
          s3 += (null == t3 ? void 0 : t3.length) || 0;
          const e4 = Math.round(s3 / n3 * 100);
          i3(e4);
        };
        try {
          for (; ; ) {
            const e4 = yield t2.read();
            if (e4.done) break;
            r2(e4.value);
          }
        } catch (t3) {
          console.warn("Progress tracking error:", t3);
        }
      }));
    })(s2.clone(), i2), s2.blob();
  }));
} };
function a(t2) {
  let e2 = t2;
  const i2 = /* @__PURE__ */ new Set();
  return { get value() {
    return e2;
  }, set(t3) {
    Object.is(e2, t3) || (e2 = t3, i2.forEach(((t4) => t4(e2))));
  }, update(t3) {
    this.set(t3(e2));
  }, subscribe: (t3) => (i2.add(t3), () => i2.delete(t3)) };
}
function l(t2, e2) {
  const i2 = a(t2());
  return e2.forEach(((e3) => e3.subscribe((() => {
    const e4 = t2();
    Object.is(i2.value, e4) || i2.set(e4);
  })))), { get value() {
    return i2.value;
  }, subscribe: (t3) => i2.subscribe(t3) };
}
function h(t2, e2) {
  let i2;
  const n2 = () => {
    i2 && (i2(), i2 = void 0), i2 = t2();
  }, s2 = e2.map(((t3) => t3.subscribe(n2)));
  return n2(), () => {
    i2 && (i2(), i2 = void 0), s2.forEach(((t3) => t3()));
  };
}
var u = class extends e {
  get isPlayingSignal() {
    return this._isPlaying;
  }
  get currentTimeSignal() {
    return this._currentTime;
  }
  get durationSignal() {
    return this._duration;
  }
  get volumeSignal() {
    return this._volume;
  }
  get mutedSignal() {
    return this._muted;
  }
  get playbackRateSignal() {
    return this._playbackRate;
  }
  get seekingSignal() {
    return this._seeking;
  }
  constructor(t2) {
    super(), this.isExternalMedia = false, this.reactiveMediaEventCleanups = [], t2.media ? (this.media = t2.media, this.isExternalMedia = true) : this.media = document.createElement("audio"), this._isPlaying = a(false), this._currentTime = a(0), this._duration = a(0), this._volume = a(this.media.volume), this._muted = a(this.media.muted), this._playbackRate = a(this.media.playbackRate || 1), this._seeking = a(false), this.setupReactiveMediaEvents(), t2.mediaControls && (this.media.controls = true), t2.autoplay && (this.media.autoplay = true), null != t2.playbackRate && this.onMediaEvent("canplay", (() => {
      null != t2.playbackRate && (this.media.playbackRate = t2.playbackRate);
    }), { once: true });
  }
  setupReactiveMediaEvents() {
    this.reactiveMediaEventCleanups.push(this.onMediaEvent("play", (() => {
      this._isPlaying.set(true);
    }))), this.reactiveMediaEventCleanups.push(this.onMediaEvent("pause", (() => {
      this._isPlaying.set(false);
    }))), this.reactiveMediaEventCleanups.push(this.onMediaEvent("ended", (() => {
      this._isPlaying.set(false);
    }))), this.reactiveMediaEventCleanups.push(this.onMediaEvent("timeupdate", (() => {
      this._currentTime.set(this.media.currentTime);
    }))), this.reactiveMediaEventCleanups.push(this.onMediaEvent("durationchange", (() => {
      this._duration.set(this.media.duration || 0);
    }))), this.reactiveMediaEventCleanups.push(this.onMediaEvent("loadedmetadata", (() => {
      this._duration.set(this.media.duration || 0);
    }))), this.reactiveMediaEventCleanups.push(this.onMediaEvent("seeking", (() => {
      this._seeking.set(true);
    }))), this.reactiveMediaEventCleanups.push(this.onMediaEvent("seeked", (() => {
      this._seeking.set(false);
    }))), this.reactiveMediaEventCleanups.push(this.onMediaEvent("volumechange", (() => {
      this._volume.set(this.media.volume), this._muted.set(this.media.muted);
    }))), this.reactiveMediaEventCleanups.push(this.onMediaEvent("ratechange", (() => {
      this._playbackRate.set(this.media.playbackRate);
    })));
  }
  onMediaEvent(t2, e2, i2) {
    return this.media.addEventListener(t2, e2, i2), () => this.media.removeEventListener(t2, e2, i2);
  }
  getSrc() {
    return this.media.currentSrc || this.media.src || "";
  }
  revokeSrc() {
    const t2 = this.getSrc();
    t2.startsWith("blob:") && URL.revokeObjectURL(t2);
  }
  canPlayType(t2) {
    return "" !== this.media.canPlayType(t2);
  }
  setSrc(t2, e2) {
    const i2 = this.getSrc();
    if (t2 && i2 === t2) return;
    this.revokeSrc();
    const n2 = e2 instanceof Blob && (this.canPlayType(e2.type) || !t2) ? URL.createObjectURL(e2) : t2;
    if (i2 && this.media.removeAttribute("src"), n2 || t2) try {
      this.media.src = n2;
    } catch (e3) {
      this.media.src = t2;
    }
  }
  destroy() {
    this.reactiveMediaEventCleanups.forEach(((t2) => t2())), this.reactiveMediaEventCleanups = [], this.isExternalMedia || (this.media.pause(), this.revokeSrc(), this.media.removeAttribute("src"), this.media.load(), this.media.remove());
  }
  setMediaElement(t2) {
    this.reactiveMediaEventCleanups.forEach(((t3) => t3())), this.reactiveMediaEventCleanups = [], this.media = t2, this.setupReactiveMediaEvents();
  }
  play() {
    return t(this, void 0, void 0, (function* () {
      try {
        return yield this.media.play();
      } catch (t2) {
        if (t2 instanceof DOMException && "AbortError" === t2.name) return;
        throw t2;
      }
    }));
  }
  pause() {
    this.media.pause();
  }
  isPlaying() {
    return !this.media.paused && !this.media.ended;
  }
  setTime(t2) {
    this.media.currentTime = Math.max(0, Math.min(t2, this.getDuration()));
  }
  getDuration() {
    return this.media.duration;
  }
  getCurrentTime() {
    return this.media.currentTime;
  }
  getVolume() {
    return this.media.volume;
  }
  setVolume(t2) {
    this.media.volume = t2;
  }
  getMuted() {
    return this.media.muted;
  }
  setMuted(t2) {
    this.media.muted = t2;
  }
  getPlaybackRate() {
    return this.media.playbackRate;
  }
  isSeeking() {
    return this.media.seeking;
  }
  setPlaybackRate(t2, e2) {
    null != e2 && (this.media.preservesPitch = e2), this.media.playbackRate = t2;
  }
  getMediaElement() {
    return this.media;
  }
  setSinkId(t2) {
    return this.media.setSinkId(t2);
  }
};
function c({ maxTop: t2, maxBottom: e2, halfHeight: i2, vScale: n2, barMinHeight: s2 = 0, barAlign: r2 }) {
  let o2 = Math.round(t2 * i2 * n2);
  let a2 = o2 + Math.round(e2 * i2 * n2) || 1;
  return a2 < s2 && (a2 = s2, r2 || (o2 = a2 / 2)), { topHeight: o2, totalHeight: a2 };
}
function d({ barAlign: t2, halfHeight: e2, topHeight: i2, totalHeight: n2, canvasHeight: s2 }) {
  return "top" === t2 ? 0 : "bottom" === t2 ? s2 - n2 : e2 - i2;
}
function p(t2, e2, i2) {
  const n2 = e2 - t2.left, s2 = i2 - t2.top;
  return [n2 / t2.width, s2 / t2.height];
}
function m(t2) {
  return Boolean(t2.barWidth || t2.barGap || t2.barAlign);
}
function g(t2, e2) {
  if (!m(e2)) return t2;
  const i2 = e2.barWidth || 0.5, n2 = i2 + (e2.barGap || i2 / 2);
  return 0 === n2 ? t2 : Math.floor(t2 / n2) * n2;
}
function v({ scrollLeft: t2, totalWidth: e2, numCanvases: i2 }) {
  if (0 === e2) return [0];
  const n2 = t2 / e2, s2 = Math.floor(n2 * i2);
  return [s2 - 1, s2, s2 + 1];
}
function f(t2) {
  const e2 = t2._cleanup;
  "function" == typeof e2 && e2();
}
function b(t2) {
  const e2 = a({ scrollLeft: t2.scrollLeft, scrollWidth: t2.scrollWidth, clientWidth: t2.clientWidth }), i2 = l((() => (function(t3) {
    const { scrollLeft: e3, scrollWidth: i3, clientWidth: n3 } = t3;
    if (0 === i3) return { startX: 0, endX: 1 };
    const s3 = e3 / i3, r2 = (e3 + n3) / i3;
    return { startX: Math.max(0, Math.min(1, s3)), endX: Math.max(0, Math.min(1, r2)) };
  })(e2.value)), [e2]), n2 = l((() => (function(t3) {
    return { left: t3.scrollLeft, right: t3.scrollLeft + t3.clientWidth };
  })(e2.value)), [e2]), s2 = () => {
    e2.set({ scrollLeft: t2.scrollLeft, scrollWidth: t2.scrollWidth, clientWidth: t2.clientWidth });
  };
  t2.addEventListener("scroll", s2, { passive: true });
  return { scrollData: e2, percentages: i2, bounds: n2, cleanup: () => {
    t2.removeEventListener("scroll", s2), f(e2);
  } };
}
var y = class extends e {
  constructor(t2, e2) {
    super(), this.timeouts = [], this.isScrollable = false, this.audioData = null, this.resizeObserver = null, this.lastContainerWidth = 0, this.isDragging = false, this.subscriptions = [], this.unsubscribeOnScroll = [], this.dragStream = null, this.scrollStream = null, this.subscriptions = [], this.options = t2;
    const i2 = this.parentFromOptionsContainer(t2.container);
    this.parent = i2;
    const [n2, s2] = this.initHtml();
    i2.appendChild(n2), this.container = n2, this.scrollContainer = s2.querySelector(".scroll"), this.wrapper = s2.querySelector(".wrapper"), this.canvasWrapper = s2.querySelector(".canvases"), this.progressWrapper = s2.querySelector(".progress"), this.cursor = s2.querySelector(".cursor"), e2 && s2.appendChild(e2), this.initEvents();
  }
  parentFromOptionsContainer(t2) {
    let e2;
    if ("string" == typeof t2 ? e2 = document.querySelector(t2) : t2 instanceof HTMLElement && (e2 = t2), !e2) throw new Error("Container not found");
    return e2;
  }
  initEvents() {
    this.wrapper.addEventListener("click", ((t3) => {
      const e2 = this.wrapper.getBoundingClientRect(), [i2, n2] = p(e2, t3.clientX, t3.clientY);
      this.emit("click", i2, n2);
    })), this.wrapper.addEventListener("dblclick", ((t3) => {
      const e2 = this.wrapper.getBoundingClientRect(), [i2, n2] = p(e2, t3.clientX, t3.clientY);
      this.emit("dblclick", i2, n2);
    })), true !== this.options.dragToSeek && "object" != typeof this.options.dragToSeek || this.initDrag(), this.scrollStream = b(this.scrollContainer);
    const t2 = h((() => {
      const { startX: t3, endX: e2 } = this.scrollStream.percentages.value, { left: i2, right: n2 } = this.scrollStream.bounds.value;
      this.emit("scroll", t3, e2, i2, n2);
    }), [this.scrollStream.percentages, this.scrollStream.bounds]);
    if (this.subscriptions.push(t2), "function" == typeof ResizeObserver) {
      const t3 = this.createDelay(100);
      this.resizeObserver = new ResizeObserver((() => {
        t3().then((() => this.onContainerResize())).catch((() => {
        }));
      })), this.resizeObserver.observe(this.scrollContainer);
    }
  }
  onContainerResize() {
    const t2 = this.parent.clientWidth;
    t2 === this.lastContainerWidth && "auto" !== this.options.height || (this.lastContainerWidth = t2, this.reRender(), this.emit("resize"));
  }
  initDrag() {
    if (this.dragStream) return;
    this.dragStream = (function(t3, e2 = {}) {
      const { threshold: i2 = 3, mouseButton: n2 = 0, touchDelay: s2 = 100 } = e2, r2 = a(null), o2 = /* @__PURE__ */ new Map(), l2 = matchMedia("(pointer: coarse)").matches;
      let h2 = () => {
      };
      const u2 = (e3) => {
        if (e3.button !== n2) return;
        if (o2.set(e3.pointerId, e3), o2.size > 1) return;
        let a2 = e3.clientX, u3 = e3.clientY, c2 = false;
        const d2 = Date.now(), p2 = t3.getBoundingClientRect(), { left: m2, top: g2 } = p2, v2 = (t4) => {
          if (t4.defaultPrevented || o2.size > 1) return;
          if (l2 && Date.now() - d2 < s2) return;
          const e4 = t4.clientX, n3 = t4.clientY, h3 = e4 - a2, p3 = n3 - u3;
          (c2 || Math.abs(h3) > i2 || Math.abs(p3) > i2) && (t4.preventDefault(), t4.stopPropagation(), c2 || (r2.set({ type: "start", x: a2 - m2, y: u3 - g2 }), c2 = true), r2.set({ type: "move", x: e4 - m2, y: n3 - g2, deltaX: h3, deltaY: p3 }), a2 = e4, u3 = n3);
        }, f2 = (t4) => {
          if (o2.delete(t4.pointerId), c2) {
            const e4 = t4.clientX, i3 = t4.clientY;
            r2.set({ type: "end", x: e4 - m2, y: i3 - g2 });
          }
          h2();
        }, b2 = (t4) => {
          o2.delete(t4.pointerId), t4.relatedTarget && t4.relatedTarget !== document.documentElement || f2(t4);
        }, y2 = (t4) => {
          c2 && (t4.stopPropagation(), t4.preventDefault());
        }, C2 = (t4) => {
          t4.defaultPrevented || o2.size > 1 || c2 && t4.preventDefault();
        };
        document.addEventListener("pointermove", v2), document.addEventListener("pointerup", f2), document.addEventListener("pointerout", b2), document.addEventListener("pointercancel", b2), document.addEventListener("touchmove", C2, { passive: false }), document.addEventListener("click", y2, { capture: true }), h2 = () => {
          document.removeEventListener("pointermove", v2), document.removeEventListener("pointerup", f2), document.removeEventListener("pointerout", b2), document.removeEventListener("pointercancel", b2), document.removeEventListener("touchmove", C2), setTimeout((() => {
            document.removeEventListener("click", y2, { capture: true });
          }), 10);
        };
      };
      return t3.addEventListener("pointerdown", u2), { signal: r2, cleanup: () => {
        h2(), t3.removeEventListener("pointerdown", u2), o2.clear(), f(r2);
      } };
    })(this.wrapper);
    const t2 = h((() => {
      const t3 = this.dragStream.signal.value;
      if (!t3) return;
      const e2 = this.wrapper.getBoundingClientRect().width, i2 = (n2 = t3.x / e2) < 0 ? 0 : n2 > 1 ? 1 : n2;
      var n2;
      "start" === t3.type ? (this.isDragging = true, this.emit("dragstart", i2)) : "move" === t3.type ? this.emit("drag", i2) : "end" === t3.type && (this.isDragging = false, this.emit("dragend", i2));
    }), [this.dragStream.signal]);
    this.subscriptions.push(t2);
  }
  initHtml() {
    const t2 = document.createElement("div"), e2 = t2.attachShadow({ mode: "open" }), i2 = this.options.cspNonce && "string" == typeof this.options.cspNonce ? this.options.cspNonce.replace(/"/g, "") : "";
    return e2.innerHTML = `
      <style${i2 ? ` nonce="${i2}"` : ""}>
        :host {
          user-select: none;
          min-width: 1px;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight(this.options.height, this.options.splitChannels)}px;
          pointer-events: none;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper" part="wrapper">
          <div class="canvases" part="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `, [t2, e2];
  }
  setOptions(t2) {
    if (this.options.container !== t2.container) {
      const e2 = this.parentFromOptionsContainer(t2.container);
      e2.appendChild(this.container), this.parent = e2;
    }
    true !== t2.dragToSeek && "object" != typeof this.options.dragToSeek || this.initDrag(), this.options = t2, this.reRender();
  }
  getWrapper() {
    return this.wrapper;
  }
  getWidth() {
    return this.scrollContainer.clientWidth;
  }
  getScroll() {
    return this.scrollContainer.scrollLeft;
  }
  setScroll(t2) {
    this.scrollContainer.scrollLeft = t2;
  }
  setScrollPercentage(t2) {
    const { scrollWidth: e2 } = this.scrollContainer, i2 = e2 * t2;
    this.setScroll(i2);
  }
  destroy() {
    var t2;
    this.subscriptions.forEach(((t3) => t3())), this.container.remove(), this.resizeObserver && (this.resizeObserver.disconnect(), this.resizeObserver = null), null === (t2 = this.unsubscribeOnScroll) || void 0 === t2 || t2.forEach(((t3) => t3())), this.unsubscribeOnScroll = [], this.dragStream && (this.dragStream.cleanup(), this.dragStream = null), this.scrollStream && (this.scrollStream.cleanup(), this.scrollStream = null);
  }
  createDelay(t2 = 10) {
    let e2, i2;
    const n2 = () => {
      e2 && (clearTimeout(e2), e2 = void 0), i2 && (i2(), i2 = void 0);
    };
    return this.timeouts.push(n2), () => new Promise(((s2, r2) => {
      n2(), i2 = r2, e2 = setTimeout((() => {
        e2 = void 0, i2 = void 0, s2();
      }), t2);
    }));
  }
  getHeight(t2, e2) {
    var i2;
    const n2 = (null === (i2 = this.audioData) || void 0 === i2 ? void 0 : i2.numberOfChannels) || 1;
    return (function({ optionsHeight: t3, optionsSplitChannels: e3, parentHeight: i3, numberOfChannels: n3, defaultHeight: s2 = 128 }) {
      if (null == t3) return s2;
      const r2 = Number(t3);
      if (!isNaN(r2)) return r2;
      if ("auto" === t3) {
        const t4 = i3 || s2;
        return (null == e3 ? void 0 : e3.every(((t5) => !t5.overlay))) ? t4 / n3 : t4;
      }
      return s2;
    })({ optionsHeight: t2, optionsSplitChannels: e2, parentHeight: this.parent.clientHeight, numberOfChannels: n2, defaultHeight: 128 });
  }
  convertColorValues(t2, e2) {
    return (function(t3, e3, i2) {
      if (!Array.isArray(t3)) return t3 || "";
      if (0 === t3.length) return "#999";
      if (t3.length < 2) return t3[0] || "";
      const n2 = document.createElement("canvas"), s2 = n2.getContext("2d"), r2 = null != i2 ? i2 : n2.height * e3, o2 = s2.createLinearGradient(0, 0, 0, r2 || e3), a2 = 1 / (t3.length - 1);
      return t3.forEach(((t4, e4) => {
        o2.addColorStop(e4 * a2, t4);
      })), o2;
    })(t2, this.getPixelRatio(), null == e2 ? void 0 : e2.canvas.height);
  }
  getPixelRatio() {
    return t2 = window.devicePixelRatio, Math.max(1, t2 || 1);
    var t2;
  }
  renderBarWaveform(t2, e2, i2, n2) {
    const { width: s2, height: r2 } = i2.canvas, { halfHeight: o2, barWidth: a2, barRadius: l2, barIndexScale: h2, barSpacing: u2, barMinHeight: p2 } = (function({ width: t3, height: e3, length: i3, options: n3, pixelRatio: s3 }) {
      const r3 = e3 / 2, o3 = n3.barWidth ? n3.barWidth * s3 : 1, a3 = n3.barGap ? n3.barGap * s3 : n3.barWidth ? o3 / 2 : 0, l3 = o3 + a3 || 1;
      return { halfHeight: r3, barWidth: o3, barGap: a3, barRadius: n3.barRadius || 0, barMinHeight: n3.barMinHeight ? n3.barMinHeight * s3 : 0, barIndexScale: i3 > 0 ? t3 / l3 / i3 : 0, barSpacing: l3 };
    })({ width: s2, height: r2, length: (t2[0] || []).length, options: e2, pixelRatio: this.getPixelRatio() }), m2 = (function({ channelData: t3, barIndexScale: e3, barSpacing: i3, barWidth: n3, halfHeight: s3, vScale: r3, canvasHeight: o3, barAlign: a3, barMinHeight: l3 }) {
      const h3 = t3[0] || [], u3 = t3[1] || h3, p3 = h3.length, m3 = [];
      let g2 = 0, v2 = 0, f2 = 0;
      for (let t4 = 0; t4 <= p3; t4++) {
        const p4 = Math.round(t4 * e3);
        if (p4 > g2) {
          const { topHeight: t5, totalHeight: e4 } = c({ maxTop: v2, maxBottom: f2, halfHeight: s3, vScale: r3, barMinHeight: l3, barAlign: a3 }), h4 = d({ barAlign: a3, halfHeight: s3, topHeight: t5, totalHeight: e4, canvasHeight: o3 });
          m3.push({ x: g2 * i3, y: h4, width: n3, height: e4 }), g2 = p4, v2 = 0, f2 = 0;
        }
        const b2 = Math.abs(h3[t4] || 0), y2 = Math.abs(u3[t4] || 0);
        b2 > v2 && (v2 = b2), y2 > f2 && (f2 = y2);
      }
      return m3;
    })({ channelData: t2, barIndexScale: h2, barSpacing: u2, barWidth: a2, halfHeight: o2, vScale: n2, canvasHeight: r2, barAlign: e2.barAlign, barMinHeight: p2 });
    i2.beginPath();
    for (const t3 of m2) l2 && "roundRect" in i2 ? i2.roundRect(t3.x, t3.y, t3.width, t3.height, l2) : i2.rect(t3.x, t3.y, t3.width, t3.height);
    i2.fill(), i2.closePath();
  }
  renderLineWaveform(t2, e2, i2, n2) {
    const { width: s2, height: r2 } = i2.canvas, o2 = (function({ channelData: t3, width: e3, height: i3, vScale: n3 }) {
      const s3 = i3 / 2, r3 = t3[0] || [];
      return [r3, t3[1] || r3].map(((t4, i4) => {
        const r4 = t4.length, o3 = r4 ? e3 / r4 : 0, a2 = s3, l2 = 0 === i4 ? -1 : 1, h2 = [{ x: 0, y: a2 }];
        let u2 = 0, c2 = 0;
        for (let e4 = 0; e4 <= r4; e4++) {
          const i5 = Math.round(e4 * o3);
          if (i5 > u2) {
            const t5 = a2 + (Math.round(c2 * s3 * n3) || 1) * l2;
            h2.push({ x: u2, y: t5 }), u2 = i5, c2 = 0;
          }
          const r5 = Math.abs(t4[e4] || 0);
          r5 > c2 && (c2 = r5);
        }
        return h2.push({ x: u2, y: a2 }), h2;
      }));
    })({ channelData: t2, width: s2, height: r2, vScale: n2 });
    i2.beginPath();
    for (const t3 of o2) if (t3.length) {
      i2.moveTo(t3[0].x, t3[0].y);
      for (let e3 = 1; e3 < t3.length; e3++) {
        const n3 = t3[e3];
        i2.lineTo(n3.x, n3.y);
      }
    }
    i2.fill(), i2.closePath();
  }
  renderWaveform(t2, e2, i2) {
    if (i2.fillStyle = this.convertColorValues(e2.waveColor, i2), e2.renderFunction) return void e2.renderFunction(t2, i2);
    const n2 = (function({ channelData: t3, barHeight: e3, normalize: i3, maxPeak: n3 }) {
      var s2;
      const r2 = e3 || 1;
      if (!i3) return r2;
      const o2 = t3[0];
      if (!o2 || 0 === o2.length) return r2;
      let a2 = null != n3 ? n3 : 0;
      if (!n3) for (let t4 = 0; t4 < o2.length; t4++) {
        const e4 = null !== (s2 = o2[t4]) && void 0 !== s2 ? s2 : 0, i4 = Math.abs(e4);
        i4 > a2 && (a2 = i4);
      }
      return a2 ? r2 / a2 : r2;
    })({ channelData: t2, barHeight: e2.barHeight, normalize: e2.normalize, maxPeak: e2.maxPeak });
    m(e2) ? this.renderBarWaveform(t2, e2, i2, n2) : this.renderLineWaveform(t2, e2, i2, n2);
  }
  renderSingleCanvas(t2, e2, i2, n2, s2, r2, o2) {
    const a2 = this.getPixelRatio(), l2 = document.createElement("canvas");
    l2.width = Math.round(i2 * a2), l2.height = Math.round(n2 * a2), l2.style.width = `${i2}px`, l2.style.height = `${n2}px`, l2.style.left = `${Math.round(s2)}px`, r2.appendChild(l2);
    const h2 = l2.getContext("2d");
    if (e2.renderFunction ? (h2.fillStyle = this.convertColorValues(e2.waveColor, h2), e2.renderFunction(t2, h2)) : this.renderWaveform(t2, e2, h2), l2.width > 0 && l2.height > 0) {
      const t3 = l2.cloneNode(), i3 = t3.getContext("2d");
      i3.drawImage(l2, 0, 0), i3.globalCompositeOperation = "source-in", i3.fillStyle = this.convertColorValues(e2.progressColor, i3), i3.fillRect(0, 0, l2.width, l2.height), o2.appendChild(t3);
    }
  }
  renderMultiCanvas(t2, e2, i2, n2, s2, r2) {
    const o2 = this.getPixelRatio(), { clientWidth: a2 } = this.scrollContainer, l2 = i2 / o2, h2 = (function({ clientWidth: t3, totalWidth: e3, options: i3 }) {
      return g(Math.min(8e3, t3, e3), i3);
    })({ clientWidth: a2, totalWidth: l2, options: e2 });
    let u2 = {};
    if (0 === h2) return;
    const c2 = (i3) => {
      if (i3 < 0 || i3 >= d2) return;
      if (u2[i3]) return;
      u2[i3] = true;
      const o3 = i3 * h2;
      let a3 = Math.min(l2 - o3, h2);
      if (a3 = g(a3, e2), a3 <= 0) return;
      const c3 = (function({ channelData: t3, offset: e3, clampedWidth: i4, totalWidth: n3 }) {
        return t3.map(((t4) => {
          const s3 = Math.floor(e3 / n3 * t4.length), r3 = Math.floor((e3 + i4) / n3 * t4.length);
          return t4.slice(s3, r3);
        }));
      })({ channelData: t2, offset: o3, clampedWidth: a3, totalWidth: l2 });
      this.renderSingleCanvas(c3, e2, a3, n2, o3, s2, r2);
    }, d2 = Math.ceil(l2 / h2);
    if (!this.isScrollable) {
      for (let t3 = 0; t3 < d2; t3++) c2(t3);
      return;
    }
    if (v({ scrollLeft: this.scrollContainer.scrollLeft, totalWidth: l2, numCanvases: d2 }).forEach(((t3) => c2(t3))), d2 > 1) {
      const t3 = this.on("scroll", (() => {
        const { scrollLeft: t4 } = this.scrollContainer;
        Object.keys(u2).length > 10 && (s2.innerHTML = "", r2.innerHTML = "", u2 = {}), v({ scrollLeft: t4, totalWidth: l2, numCanvases: d2 }).forEach(((t5) => c2(t5)));
      }));
      this.unsubscribeOnScroll.push(t3);
    }
  }
  renderChannel(t2, e2, i2, n2) {
    var { overlay: s2 } = e2, r2 = (function(t3, e3) {
      var i3 = {};
      for (var n3 in t3) Object.prototype.hasOwnProperty.call(t3, n3) && e3.indexOf(n3) < 0 && (i3[n3] = t3[n3]);
      if (null != t3 && "function" == typeof Object.getOwnPropertySymbols) {
        var s3 = 0;
        for (n3 = Object.getOwnPropertySymbols(t3); s3 < n3.length; s3++) e3.indexOf(n3[s3]) < 0 && Object.prototype.propertyIsEnumerable.call(t3, n3[s3]) && (i3[n3[s3]] = t3[n3[s3]]);
      }
      return i3;
    })(e2, ["overlay"]);
    const o2 = document.createElement("div"), a2 = this.getHeight(r2.height, r2.splitChannels);
    o2.style.height = `${a2}px`, s2 && n2 > 0 && (o2.style.marginTop = `-${a2}px`), this.canvasWrapper.style.minHeight = `${a2}px`, this.canvasWrapper.appendChild(o2);
    const l2 = o2.cloneNode();
    this.progressWrapper.appendChild(l2), this.renderMultiCanvas(t2, r2, i2, a2, o2, l2);
  }
  render(e2) {
    return t(this, void 0, void 0, (function* () {
      var t2;
      this.timeouts.forEach(((t3) => t3())), this.timeouts = [], this.canvasWrapper.innerHTML = "", this.progressWrapper.innerHTML = "", null != this.options.width && (this.scrollContainer.style.width = "number" == typeof this.options.width ? `${this.options.width}px` : this.options.width);
      const i2 = this.getPixelRatio(), n2 = this.scrollContainer.clientWidth, { scrollWidth: s2, isScrollable: r2, useParentWidth: o2, width: a2 } = (function({ duration: t3, minPxPerSec: e3 = 0, parentWidth: i3, fillParent: n3, pixelRatio: s3 }) {
        const r3 = Math.ceil(t3 * e3), o3 = r3 > i3, a3 = Boolean(n3 && !o3);
        return { scrollWidth: r3, isScrollable: o3, useParentWidth: a3, width: (a3 ? i3 : r3) * s3 };
      })({ duration: e2.duration, minPxPerSec: this.options.minPxPerSec || 0, parentWidth: n2, fillParent: this.options.fillParent, pixelRatio: i2 });
      if (this.isScrollable = r2, this.wrapper.style.width = o2 ? "100%" : `${s2}px`, this.scrollContainer.style.overflowX = this.isScrollable ? "auto" : "hidden", this.scrollContainer.classList.toggle("noScrollbar", !!this.options.hideScrollbar), this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`, this.cursor.style.width = `${this.options.cursorWidth}px`, this.audioData = e2, this.emit("render"), this.options.splitChannels) for (let i3 = 0; i3 < e2.numberOfChannels; i3++) {
        const n3 = Object.assign(Object.assign({}, this.options), null === (t2 = this.options.splitChannels) || void 0 === t2 ? void 0 : t2[i3]);
        this.renderChannel([e2.getChannelData(i3)], n3, a2, i3);
      }
      else {
        const t3 = [e2.getChannelData(0)];
        e2.numberOfChannels > 1 && t3.push(e2.getChannelData(1)), this.renderChannel(t3, this.options, a2, 0);
      }
      Promise.resolve().then((() => this.emit("rendered")));
    }));
  }
  reRender() {
    if (this.unsubscribeOnScroll.forEach(((t3) => t3())), this.unsubscribeOnScroll = [], !this.audioData) return;
    const { scrollWidth: t2 } = this.scrollContainer, { right: e2 } = this.progressWrapper.getBoundingClientRect();
    if (this.render(this.audioData), this.isScrollable && t2 !== this.scrollContainer.scrollWidth) {
      const { right: t3 } = this.progressWrapper.getBoundingClientRect(), i2 = (function(t4) {
        const e3 = 2 * t4;
        return (e3 < 0 ? Math.floor(e3) : Math.ceil(e3)) / 2;
      })(t3 - e2);
      this.scrollContainer.scrollLeft += i2;
    }
  }
  zoom(t2) {
    this.options.minPxPerSec = t2, this.reRender();
  }
  scrollIntoView(t2, e2 = false) {
    const { scrollLeft: i2, scrollWidth: n2, clientWidth: s2 } = this.scrollContainer, r2 = t2 * n2, o2 = i2, a2 = i2 + s2, l2 = s2 / 2;
    if (this.isDragging) {
      const t3 = 30;
      r2 + t3 > a2 ? this.scrollContainer.scrollLeft += t3 : r2 - t3 < o2 && (this.scrollContainer.scrollLeft -= t3);
    } else {
      (r2 < o2 || r2 > a2) && (this.scrollContainer.scrollLeft = r2 - (this.options.autoCenter ? l2 : 0));
      const t3 = r2 - i2 - l2;
      e2 && this.options.autoCenter && t3 > 0 && (this.scrollContainer.scrollLeft += t3);
    }
  }
  renderProgress(t2, e2) {
    if (isNaN(t2)) return;
    const i2 = 100 * t2;
    this.canvasWrapper.style.clipPath = `polygon(${i2}% 0%, 100% 0%, 100% 100%, ${i2}% 100%)`, this.progressWrapper.style.width = `${i2}%`, this.cursor.style.left = `${i2}%`, this.cursor.style.transform = this.options.cursorWidth ? `translateX(-${t2 * this.options.cursorWidth}px)` : "", this.isScrollable && this.options.autoScroll && this.audioData && this.audioData.duration > 0 && this.scrollIntoView(t2, e2);
  }
  exportImage(e2, i2, n2) {
    return t(this, void 0, void 0, (function* () {
      const t2 = this.canvasWrapper.querySelectorAll("canvas");
      if (!t2.length) throw new Error("No waveform data");
      if ("dataURL" === n2) {
        const n3 = Array.from(t2).map(((t3) => t3.toDataURL(e2, i2)));
        return Promise.resolve(n3);
      }
      return Promise.all(Array.from(t2).map(((t3) => new Promise(((n3, s2) => {
        t3.toBlob(((t4) => {
          t4 ? n3(t4) : s2(new Error("Could not export image"));
        }), e2, i2);
      })))));
    }));
  }
};
var C = class extends e {
  constructor() {
    super(...arguments), this.animationFrameId = null, this.isRunning = false;
  }
  start() {
    if (this.isRunning) return;
    this.isRunning = true;
    const t2 = () => {
      this.isRunning && (this.emit("tick"), this.animationFrameId = requestAnimationFrame(t2));
    };
    t2();
  }
  stop() {
    this.isRunning = false, null !== this.animationFrameId && (cancelAnimationFrame(this.animationFrameId), this.animationFrameId = null);
  }
  destroy() {
    this.stop();
  }
};
var S = class extends e {
  constructor(t2 = new AudioContext()) {
    super(), this.bufferNode = null, this.playStartTime = 0, this.playedDuration = 0, this._muted = false, this._playbackRate = 1, this._duration = void 0, this.buffer = null, this.currentSrc = "", this.paused = true, this.crossOrigin = null, this.seeking = false, this.autoplay = false, this.addEventListener = this.on, this.removeEventListener = this.un, this.audioContext = t2, this.gainNode = this.audioContext.createGain(), this.gainNode.connect(this.audioContext.destination);
  }
  load() {
    return t(this, void 0, void 0, (function* () {
    }));
  }
  get src() {
    return this.currentSrc;
  }
  set src(t2) {
    if (this.currentSrc = t2, this._duration = void 0, !t2) return this.buffer = null, void this.emit("emptied");
    fetch(t2).then(((e2) => {
      if (e2.status >= 400) throw new Error(`Failed to fetch ${t2}: ${e2.status} (${e2.statusText})`);
      return e2.arrayBuffer();
    })).then(((e2) => this.currentSrc !== t2 ? null : this.audioContext.decodeAudioData(e2))).then(((e2) => {
      this.currentSrc === t2 && (this.buffer = e2, this.emit("loadedmetadata"), this.emit("canplay"), this.autoplay && this.play());
    })).catch(((t3) => {
      console.error("WebAudioPlayer load error:", t3);
    }));
  }
  _play() {
    if (!this.paused) return;
    this.paused = false, this.bufferNode && (this.bufferNode.onended = null, this.bufferNode.disconnect()), this.bufferNode = this.audioContext.createBufferSource(), this.buffer && (this.bufferNode.buffer = this.buffer), this.bufferNode.playbackRate.value = this._playbackRate, this.bufferNode.connect(this.gainNode);
    let t2 = this.playedDuration * this._playbackRate;
    (t2 >= this.duration || t2 < 0) && (t2 = 0, this.playedDuration = 0), this.bufferNode.start(this.audioContext.currentTime, t2), this.playStartTime = this.audioContext.currentTime, this.bufferNode.onended = () => {
      this.currentTime >= this.duration && (this.pause(), this.emit("ended"));
    };
  }
  _pause() {
    var t2;
    this.paused = true, null === (t2 = this.bufferNode) || void 0 === t2 || t2.stop(), this.playedDuration += this.audioContext.currentTime - this.playStartTime;
  }
  play() {
    return t(this, void 0, void 0, (function* () {
      this.paused && (this._play(), this.emit("play"));
    }));
  }
  pause() {
    this.paused || (this._pause(), this.emit("pause"));
  }
  stopAt(t2) {
    const e2 = t2 - this.currentTime, i2 = this.bufferNode;
    null == i2 || i2.stop(this.audioContext.currentTime + e2), null == i2 || i2.addEventListener("ended", (() => {
      i2 === this.bufferNode && (this.bufferNode = null, this.pause());
    }), { once: true });
  }
  setSinkId(e2) {
    return t(this, void 0, void 0, (function* () {
      return this.audioContext.setSinkId(e2);
    }));
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(t2) {
    this._playbackRate = t2, this.bufferNode && (this.bufferNode.playbackRate.value = t2);
  }
  get currentTime() {
    return (this.paused ? this.playedDuration : this.playedDuration + (this.audioContext.currentTime - this.playStartTime)) * this._playbackRate;
  }
  set currentTime(t2) {
    const e2 = !this.paused;
    e2 && this._pause(), this.playedDuration = t2 / this._playbackRate, e2 && this._play(), this.emit("seeking"), this.emit("timeupdate");
  }
  get duration() {
    var t2, e2;
    return null !== (t2 = this._duration) && void 0 !== t2 ? t2 : (null === (e2 = this.buffer) || void 0 === e2 ? void 0 : e2.duration) || 0;
  }
  set duration(t2) {
    this._duration = t2;
  }
  get volume() {
    return this.gainNode.gain.value;
  }
  set volume(t2) {
    this.gainNode.gain.value = t2, this.emit("volumechange");
  }
  get muted() {
    return this._muted;
  }
  set muted(t2) {
    this._muted !== t2 && (this._muted = t2, this._muted ? this.gainNode.disconnect() : this.gainNode.connect(this.audioContext.destination));
  }
  canPlayType(t2) {
    return /^(audio|video)\//.test(t2);
  }
  getGainNode() {
    return this.gainNode;
  }
  getChannelData() {
    const t2 = [];
    if (!this.buffer) return t2;
    const e2 = this.buffer.numberOfChannels;
    for (let i2 = 0; i2 < e2; i2++) t2.push(this.buffer.getChannelData(i2));
    return t2;
  }
  removeAttribute(t2) {
    switch (t2) {
      case "src":
        this.src = "";
        break;
      case "playbackRate":
        this.playbackRate = 0;
        break;
      case "currentTime":
        this.currentTime = 0;
        break;
      case "duration":
        this.duration = 0;
        break;
      case "volume":
        this.volume = 0;
        break;
      case "muted":
        this.muted = false;
    }
  }
};
var E = { waveColor: "#999", progressColor: "#555", cursorWidth: 1, minPxPerSec: 0, fillParent: true, interact: true, dragToSeek: false, autoScroll: true, autoCenter: true, sampleRate: 8e3 };
var w = class _w extends u {
  static create(t2) {
    return new _w(t2);
  }
  getState() {
    return this.wavesurferState;
  }
  getRenderer() {
    return this.renderer;
  }
  constructor(t2) {
    const e2 = t2.media || ("WebAudio" === t2.backend ? new S() : void 0);
    super({ media: e2, mediaControls: t2.mediaControls, autoplay: t2.autoplay, playbackRate: t2.audioRate }), this.plugins = [], this.decodedData = null, this.stopAtPosition = null, this.subscriptions = [], this.mediaSubscriptions = [], this.abortController = null, this.reactiveCleanups = [], this.options = Object.assign({}, E, t2);
    const { state: i2, actions: n2 } = (function(t3) {
      var e3, i3, n3, s3, r3, o2;
      const h2 = null !== (e3 = null == t3 ? void 0 : t3.currentTime) && void 0 !== e3 ? e3 : a(0), u2 = null !== (i3 = null == t3 ? void 0 : t3.duration) && void 0 !== i3 ? i3 : a(0), c2 = null !== (n3 = null == t3 ? void 0 : t3.isPlaying) && void 0 !== n3 ? n3 : a(false), d2 = null !== (s3 = null == t3 ? void 0 : t3.isSeeking) && void 0 !== s3 ? s3 : a(false), p2 = null !== (r3 = null == t3 ? void 0 : t3.volume) && void 0 !== r3 ? r3 : a(1), m2 = null !== (o2 = null == t3 ? void 0 : t3.playbackRate) && void 0 !== o2 ? o2 : a(1), g2 = a(null), v2 = a(null), f2 = a(""), b2 = a(0), y2 = a(0), C2 = l((() => !c2.value), [c2]), S2 = l((() => null !== g2.value), [g2]), E2 = l((() => S2.value && u2.value > 0), [S2, u2]), w2 = l((() => h2.value), [h2]), P = l((() => u2.value > 0 ? h2.value / u2.value : 0), [h2, u2]);
      return { state: { currentTime: h2, duration: u2, isPlaying: c2, isPaused: C2, isSeeking: d2, volume: p2, playbackRate: m2, audioBuffer: g2, peaks: v2, url: f2, zoom: b2, scrollPosition: y2, canPlay: S2, isReady: E2, progress: w2, progressPercent: P }, actions: { setCurrentTime: (t4) => {
        const e4 = Math.max(0, Math.min(u2.value || 1 / 0, t4));
        h2.set(e4);
      }, setDuration: (t4) => {
        u2.set(Math.max(0, t4));
      }, setPlaying: (t4) => {
        c2.set(t4);
      }, setSeeking: (t4) => {
        d2.set(t4);
      }, setVolume: (t4) => {
        const e4 = Math.max(0, Math.min(1, t4));
        p2.set(e4);
      }, setPlaybackRate: (t4) => {
        const e4 = Math.max(0.1, Math.min(16, t4));
        m2.set(e4);
      }, setAudioBuffer: (t4) => {
        g2.set(t4), t4 && u2.set(t4.duration);
      }, setPeaks: (t4) => {
        v2.set(t4);
      }, setUrl: (t4) => {
        f2.set(t4);
      }, setZoom: (t4) => {
        b2.set(Math.max(0, t4));
      }, setScrollPosition: (t4) => {
        y2.set(Math.max(0, t4));
      } } };
    })({ isPlaying: this.isPlayingSignal, currentTime: this.currentTimeSignal, duration: this.durationSignal, volume: this.volumeSignal, playbackRate: this.playbackRateSignal, isSeeking: this.seekingSignal });
    this.wavesurferState = i2, this.wavesurferActions = n2, this.timer = new C();
    const s2 = e2 ? void 0 : this.getMediaElement();
    this.renderer = new y(this.options, s2), this.initPlayerEvents(), this.initRendererEvents(), this.initTimerEvents(), this.initReactiveState(), this.initPlugins();
    const r2 = this.options.url || this.getSrc() || "";
    Promise.resolve().then((() => {
      this.emit("init");
      const { peaks: t3, duration: e3 } = this.options;
      (r2 || t3 && e3) && this.load(r2, t3, e3).catch(((t4) => {
        this.emit("error", t4 instanceof Error ? t4 : new Error(String(t4)));
      }));
    }));
  }
  updateProgress(t2 = this.getCurrentTime()) {
    return this.renderer.renderProgress(t2 / this.getDuration(), this.isPlaying()), t2;
  }
  initTimerEvents() {
    this.subscriptions.push(this.timer.on("tick", (() => {
      if (!this.isSeeking()) {
        const t2 = this.updateProgress();
        this.emit("timeupdate", t2), this.emit("audioprocess", t2), null != this.stopAtPosition && this.isPlaying() && t2 >= this.stopAtPosition && this.pause();
      }
    })));
  }
  initReactiveState() {
    this.reactiveCleanups.push((function(t2, e2) {
      const i2 = [];
      i2.push(h((() => {
        const i3 = t2.isPlaying.value;
        e2.emit(i3 ? "play" : "pause");
      }), [t2.isPlaying])), i2.push(h((() => {
        const i3 = t2.currentTime.value;
        e2.emit("timeupdate", i3), t2.isPlaying.value && e2.emit("audioprocess", i3);
      }), [t2.currentTime, t2.isPlaying])), i2.push(h((() => {
        t2.isSeeking.value && e2.emit("seeking", t2.currentTime.value);
      }), [t2.isSeeking, t2.currentTime]));
      let n2 = false;
      i2.push(h((() => {
        t2.isReady.value && !n2 && (n2 = true, e2.emit("ready", t2.duration.value));
      }), [t2.isReady, t2.duration]));
      let s2 = false;
      return i2.push(h((() => {
        const i3 = t2.isPlaying.value, n3 = t2.currentTime.value, r2 = t2.duration.value, o2 = r2 > 0 && n3 >= r2;
        s2 && !i3 && o2 && e2.emit("finish"), s2 = i3 && o2;
      }), [t2.isPlaying, t2.currentTime, t2.duration])), i2.push(h((() => {
        const i3 = t2.zoom.value;
        i3 > 0 && e2.emit("zoom", i3);
      }), [t2.zoom])), () => {
        i2.forEach(((t3) => t3()));
      };
    })(this.wavesurferState, { emit: this.emit.bind(this) }));
  }
  initPlayerEvents() {
    this.isPlaying() && (this.emit("play"), this.timer.start()), this.mediaSubscriptions.push(this.onMediaEvent("timeupdate", (() => {
      const t2 = this.updateProgress();
      this.emit("timeupdate", t2);
    })), this.onMediaEvent("play", (() => {
      this.emit("play"), this.timer.start();
    })), this.onMediaEvent("pause", (() => {
      this.emit("pause"), this.timer.stop(), this.stopAtPosition = null;
    })), this.onMediaEvent("emptied", (() => {
      this.timer.stop(), this.stopAtPosition = null;
    })), this.onMediaEvent("ended", (() => {
      this.emit("timeupdate", this.getDuration()), this.emit("finish"), this.stopAtPosition = null;
    })), this.onMediaEvent("seeking", (() => {
      this.emit("seeking", this.getCurrentTime());
    })), this.onMediaEvent("error", (() => {
      var t2;
      this.emit("error", null !== (t2 = this.getMediaElement().error) && void 0 !== t2 ? t2 : new Error("Media error")), this.stopAtPosition = null;
    })));
  }
  initRendererEvents() {
    this.subscriptions.push(this.renderer.on("click", ((t2, e2) => {
      this.options.interact && (this.seekTo(t2), this.emit("interaction", t2 * this.getDuration()), this.emit("click", t2, e2));
    })), this.renderer.on("dblclick", ((t2, e2) => {
      this.emit("dblclick", t2, e2);
    })), this.renderer.on("scroll", ((t2, e2, i2, n2) => {
      const s2 = this.getDuration();
      this.emit("scroll", t2 * s2, e2 * s2, i2, n2);
    })), this.renderer.on("render", (() => {
      this.emit("redraw");
    })), this.renderer.on("rendered", (() => {
      this.emit("redrawcomplete");
    })), this.renderer.on("dragstart", ((t2) => {
      this.emit("dragstart", t2);
    })), this.renderer.on("dragend", ((t2) => {
      this.emit("dragend", t2);
    })), this.renderer.on("resize", (() => {
      this.emit("resize");
    })));
    {
      let t2;
      const e2 = this.renderer.on("drag", ((e3) => {
        var i2;
        if (!this.options.interact) return;
        this.renderer.renderProgress(e3), clearTimeout(t2);
        let n2 = 0;
        const s2 = this.options.dragToSeek;
        this.isPlaying() ? n2 = 0 : true === s2 ? n2 = 200 : s2 && "object" == typeof s2 && (n2 = null !== (i2 = s2.debounceTime) && void 0 !== i2 ? i2 : 200), t2 = setTimeout((() => {
          this.seekTo(e3);
        }), n2), this.emit("interaction", e3 * this.getDuration()), this.emit("drag", e3);
      }));
      this.subscriptions.push((() => {
        clearTimeout(t2), e2();
      }));
    }
  }
  initPlugins() {
    var t2;
    (null === (t2 = this.options.plugins) || void 0 === t2 ? void 0 : t2.length) && this.options.plugins.forEach(((t3) => {
      this.registerPlugin(t3);
    }));
  }
  unsubscribePlayerEvents() {
    this.mediaSubscriptions.forEach(((t2) => t2())), this.mediaSubscriptions = [];
  }
  setOptions(t2) {
    this.options = Object.assign({}, this.options, t2), t2.duration && !t2.peaks && (this.decodedData = i.createBuffer(this.exportPeaks(), t2.duration)), t2.peaks && t2.duration && (this.decodedData = i.createBuffer(t2.peaks, t2.duration)), this.renderer.setOptions(this.options), t2.audioRate && this.setPlaybackRate(t2.audioRate), null != t2.mediaControls && (this.getMediaElement().controls = t2.mediaControls);
  }
  registerPlugin(t2) {
    if (this.plugins.includes(t2)) return t2;
    t2._init(this), this.plugins.push(t2);
    const e2 = t2.once("destroy", (() => {
      this.plugins = this.plugins.filter(((e3) => e3 !== t2)), this.subscriptions = this.subscriptions.filter(((t3) => t3 !== e2));
    }));
    return this.subscriptions.push(e2), t2;
  }
  unregisterPlugin(t2) {
    this.plugins = this.plugins.filter(((e2) => e2 !== t2)), t2.destroy();
  }
  getWrapper() {
    return this.renderer.getWrapper();
  }
  getWidth() {
    return this.renderer.getWidth();
  }
  getScroll() {
    return this.renderer.getScroll();
  }
  setScroll(t2) {
    return this.renderer.setScroll(t2);
  }
  setScrollTime(t2) {
    const e2 = t2 / this.getDuration();
    this.renderer.setScrollPercentage(e2);
  }
  getActivePlugins() {
    return this.plugins;
  }
  loadAudio(e2, n2, s2, r2) {
    return t(this, void 0, void 0, (function* () {
      var t2;
      if (this.emit("load", e2), !this.options.media && this.isPlaying() && this.pause(), this.decodedData = null, this.stopAtPosition = null, null === (t2 = this.abortController) || void 0 === t2 || t2.abort(), this.abortController = null, !n2 && !s2) {
        const t3 = this.options.fetchParams || {};
        window.AbortController && !t3.signal && (this.abortController = new AbortController(), t3.signal = this.abortController.signal);
        const i2 = (t4) => this.emit("loading", t4);
        n2 = yield o.fetchBlob(e2, i2, t3);
        const s3 = this.options.blobMimeType;
        s3 && (n2 = new Blob([n2], { type: s3 }));
      }
      this.setSrc(e2, n2);
      const a2 = yield new Promise(((t3) => {
        const e3 = r2 || this.getDuration();
        e3 ? t3(e3) : this.mediaSubscriptions.push(this.onMediaEvent("loadedmetadata", (() => t3(this.getDuration())), { once: true }));
      }));
      if (!e2 && !n2) {
        const t3 = this.getMediaElement();
        t3 instanceof S && (t3.duration = a2);
      }
      if (s2) this.decodedData = i.createBuffer(s2, a2 || 0);
      else if (n2) {
        const t3 = yield n2.arrayBuffer();
        this.decodedData = yield i.decode(t3, this.options.sampleRate);
      }
      this.decodedData && (this.emit("decode", this.getDuration()), this.renderer.render(this.decodedData)), this.emit("ready", this.getDuration());
    }));
  }
  load(e2, i2, n2) {
    return t(this, void 0, void 0, (function* () {
      try {
        return yield this.loadAudio(e2, void 0, i2, n2);
      } catch (t2) {
        throw this.emit("error", t2), t2;
      }
    }));
  }
  loadBlob(e2, i2, n2) {
    return t(this, void 0, void 0, (function* () {
      try {
        return yield this.loadAudio("", e2, i2, n2);
      } catch (t2) {
        throw this.emit("error", t2), t2;
      }
    }));
  }
  zoom(t2) {
    if (!this.decodedData) throw new Error("No audio loaded");
    this.renderer.zoom(t2), this.emit("zoom", t2);
  }
  getDecodedData() {
    return this.decodedData;
  }
  exportPeaks({ channels: t2 = 2, maxLength: e2 = 8e3, precision: i2 = 1e4 } = {}) {
    if (!this.decodedData) throw new Error("The audio has not been decoded yet");
    const n2 = Math.min(t2, this.decodedData.numberOfChannels), s2 = [];
    for (let t3 = 0; t3 < n2; t3++) {
      const n3 = this.decodedData.getChannelData(t3), r2 = [], o2 = n3.length / e2;
      for (let t4 = 0; t4 < e2; t4++) {
        const e3 = n3.slice(Math.floor(t4 * o2), Math.ceil((t4 + 1) * o2));
        let s3 = 0;
        for (let t5 = 0; t5 < e3.length; t5++) {
          const i3 = e3[t5];
          Math.abs(i3) > Math.abs(s3) && (s3 = i3);
        }
        r2.push(Math.round(s3 * i2) / i2);
      }
      s2.push(r2);
    }
    return s2;
  }
  getDuration() {
    let t2 = super.getDuration() || 0;
    return 0 !== t2 && t2 !== 1 / 0 || !this.decodedData || (t2 = this.decodedData.duration), t2;
  }
  toggleInteraction(t2) {
    this.options.interact = t2;
  }
  setTime(t2) {
    this.stopAtPosition = null, super.setTime(t2), this.updateProgress(t2), this.emit("timeupdate", t2);
  }
  seekTo(t2) {
    const e2 = this.getDuration() * t2;
    this.setTime(e2);
  }
  play(e2, i2) {
    const n2 = Object.create(null, { play: { get: () => super.play } });
    return t(this, void 0, void 0, (function* () {
      null != e2 && this.setTime(e2);
      const t2 = yield n2.play.call(this);
      return null != i2 && (this.media instanceof S ? this.media.stopAt(i2) : this.stopAtPosition = i2), t2;
    }));
  }
  playPause() {
    return t(this, void 0, void 0, (function* () {
      return this.isPlaying() ? this.pause() : this.play();
    }));
  }
  stop() {
    this.pause(), this.setTime(0);
  }
  skip(t2) {
    this.setTime(this.getCurrentTime() + t2);
  }
  empty() {
    this.load("", [[0]], 1e-3);
  }
  setMediaElement(t2) {
    this.unsubscribePlayerEvents(), super.setMediaElement(t2), this.initPlayerEvents();
  }
  exportImage() {
    return t(this, arguments, void 0, (function* (t2 = "image/png", e2 = 1, i2 = "dataURL") {
      return this.renderer.exportImage(t2, e2, i2);
    }));
  }
  destroy() {
    var t2;
    this.emit("destroy"), null === (t2 = this.abortController) || void 0 === t2 || t2.abort(), this.plugins.forEach(((t3) => t3.destroy())), this.subscriptions.forEach(((t3) => t3())), this.unsubscribePlayerEvents(), this.reactiveCleanups.forEach(((t3) => t3())), this.reactiveCleanups = [], this.timer.destroy(), this.renderer.destroy(), super.destroy();
  }
};
w.BasePlugin = class extends e {
  constructor(t2) {
    super(), this.subscriptions = [], this.isDestroyed = false, this.options = t2;
  }
  onInit() {
  }
  _init(t2) {
    this.isDestroyed && (this.subscriptions = [], this.isDestroyed = false), this.wavesurfer = t2, this.onInit();
  }
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach(((t2) => t2())), this.subscriptions = [], this.isDestroyed = true, this.wavesurfer = void 0;
  }
}, w.dom = r;
export {
  w as default
};
//# sourceMappingURL=wavesurfer__js.js.map
