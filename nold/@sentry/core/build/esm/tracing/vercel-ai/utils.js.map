{"version":3,"file":"utils.js","sources":["../../../../src/tracing/vercel-ai/utils.ts"],"sourcesContent":["import type { TraceContext } from '../../types-hoist/context';\nimport type { Span, SpanAttributes, SpanJSON } from '../../types-hoist/span';\nimport {\n  GEN_AI_REQUEST_MESSAGES_ATTRIBUTE,\n  GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE,\n  GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport { getTruncatedJsonString } from '../ai/utils';\nimport { toolCallSpanMap } from './constants';\nimport type { TokenSummary } from './types';\nimport { AI_PROMPT_ATTRIBUTE, AI_PROMPT_MESSAGES_ATTRIBUTE } from './vercel-ai-attributes';\n\n/**\n * Accumulates token data from a span to its parent in the token accumulator map.\n * This function extracts token usage from the current span and adds it to the\n * accumulated totals for its parent span.\n */\nexport function accumulateTokensForParent(span: SpanJSON, tokenAccumulator: Map<string, TokenSummary>): void {\n  const parentSpanId = span.parent_span_id;\n  if (!parentSpanId) {\n    return;\n  }\n\n  const inputTokens = span.data[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE];\n  const outputTokens = span.data[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE];\n\n  if (typeof inputTokens === 'number' || typeof outputTokens === 'number') {\n    const existing = tokenAccumulator.get(parentSpanId) || { inputTokens: 0, outputTokens: 0 };\n\n    if (typeof inputTokens === 'number') {\n      existing.inputTokens += inputTokens;\n    }\n    if (typeof outputTokens === 'number') {\n      existing.outputTokens += outputTokens;\n    }\n\n    tokenAccumulator.set(parentSpanId, existing);\n  }\n}\n\n/**\n * Applies accumulated token data to the `gen_ai.invoke_agent` span.\n * Only immediate children of the `gen_ai.invoke_agent` span are considered,\n * since aggregation will automatically occur for each parent span.\n */\nexport function applyAccumulatedTokens(\n  spanOrTrace: SpanJSON | TraceContext,\n  tokenAccumulator: Map<string, TokenSummary>,\n): void {\n  const accumulated = tokenAccumulator.get(spanOrTrace.span_id);\n  if (!accumulated || !spanOrTrace.data) {\n    return;\n  }\n\n  if (accumulated.inputTokens > 0) {\n    spanOrTrace.data[GEN_AI_USAGE_INPUT_TOKENS_ATTRIBUTE] = accumulated.inputTokens;\n  }\n  if (accumulated.outputTokens > 0) {\n    spanOrTrace.data[GEN_AI_USAGE_OUTPUT_TOKENS_ATTRIBUTE] = accumulated.outputTokens;\n  }\n  if (accumulated.inputTokens > 0 || accumulated.outputTokens > 0) {\n    spanOrTrace.data['gen_ai.usage.total_tokens'] = accumulated.inputTokens + accumulated.outputTokens;\n  }\n}\n\n/**\n * Get the span associated with a tool call ID\n */\nexport function _INTERNAL_getSpanForToolCallId(toolCallId: string): Span | undefined {\n  return toolCallSpanMap.get(toolCallId);\n}\n\n/**\n * Clean up the span mapping for a tool call ID\n */\nexport function _INTERNAL_cleanupToolCallSpan(toolCallId: string): void {\n  toolCallSpanMap.delete(toolCallId);\n}\n\n/**\n * Convert an array of tool strings to a JSON string\n */\nexport function convertAvailableToolsToJsonString(tools: unknown[]): string {\n  const toolObjects = tools.map(tool => {\n    if (typeof tool === 'string') {\n      try {\n        return JSON.parse(tool);\n      } catch {\n        return tool;\n      }\n    }\n    return tool;\n  });\n  return JSON.stringify(toolObjects);\n}\n\n/**\n * Convert the prompt string to messages array\n */\nexport function convertPromptToMessages(prompt: string): { role: string; content: string }[] {\n  try {\n    const p = JSON.parse(prompt);\n    if (!!p && typeof p === 'object') {\n      const { prompt, system } = p;\n      if (typeof prompt === 'string' || typeof system === 'string') {\n        const messages: { role: string; content: string }[] = [];\n        if (typeof system === 'string') {\n          messages.push({ role: 'system', content: system });\n        }\n        if (typeof prompt === 'string') {\n          messages.push({ role: 'user', content: prompt });\n        }\n        return messages;\n      }\n    }\n    // eslint-disable-next-line no-empty\n  } catch {}\n  return [];\n}\n\n/**\n * Generate a request.messages JSON array from the prompt field in the\n * invoke_agent op\n */\nexport function requestMessagesFromPrompt(span: Span, attributes: SpanAttributes): void {\n  if (attributes[AI_PROMPT_ATTRIBUTE]) {\n    const truncatedPrompt = getTruncatedJsonString(attributes[AI_PROMPT_ATTRIBUTE] as string | string[]);\n    span.setAttribute('gen_ai.prompt', truncatedPrompt);\n  }\n  const prompt = attributes[AI_PROMPT_ATTRIBUTE];\n  if (\n    typeof prompt === 'string' &&\n    !attributes[GEN_AI_REQUEST_MESSAGES_ATTRIBUTE] &&\n    !attributes[AI_PROMPT_MESSAGES_ATTRIBUTE]\n  ) {\n    const messages = convertPromptToMessages(prompt);\n    if (messages.length) span.setAttribute(GEN_AI_REQUEST_MESSAGES_ATTRIBUTE, getTruncatedJsonString(messages));\n  }\n}\n"],"names":[],"mappings":"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"}