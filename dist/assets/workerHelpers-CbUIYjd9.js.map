{"version":3,"file":"workerHelpers-CbUIYjd9.js","sources":["../src/pkg/spectrogram/snippets/wasm-bindgen-rayon-38edf6e439f6d70d/src/workerHelpers.js"],"sourcesContent":["/*\n * Copyright 2022 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *     http://www.apache.org/licenses/LICENSE-2.0\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Note: we use `wasm_bindgen_worker_`-prefixed message types to make sure\n// we can handle bundling into other files, which might happen to have their\n// own `postMessage`/`onmessage` communication channels.\n//\n// If we didn't take that into the account, we could send much simpler signals\n// like just `0` or whatever, but the code would be less resilient.\n\nfunction waitForMsgType(target, type) {\n  return new Promise(resolve => {\n    target.addEventListener('message', function onMsg({ data }) {\n      if (data?.type !== type) return;\n      target.removeEventListener('message', onMsg);\n      resolve(data);\n    });\n  });\n}\n\nwaitForMsgType(self, 'wasm_bindgen_worker_init').then(async ({ init, receiver }) => {\n  // # Note 1\n  // Our JS should have been generated in\n  // `[out-dir]/snippets/wasm-bindgen-rayon-[hash]/workerHelpers.js`,\n  // resolve the main module via `../../..`.\n  //\n  // This might need updating if the generated structure changes on wasm-bindgen\n  // side ever in the future, but works well with bundlers today. The whole\n  // point of this crate, after all, is to abstract away unstable features\n  // and temporary bugs so that you don't need to deal with them in your code.\n  //\n  // # Note 2\n  // This could be a regular import, but then some bundlers complain about\n  // circular deps.\n  //\n  // Dynamic import could be cheap if this file was inlined into the parent,\n  // which would require us just using `../../..` in `new Worker` below,\n  // but that doesn't work because wasm-pack unconditionally adds\n  // \"sideEffects\":false (see below).\n  //\n  // OTOH, even though it can't be inlined, it should be still reasonably\n  // cheap since the requested file is already in cache (it was loaded by\n  // the main thread).\n  const pkg = await import('../../..');\n  await pkg.default(init);\n  postMessage({ type: 'wasm_bindgen_worker_ready' });\n  pkg.wbg_rayon_start_worker(receiver);\n});\n\n// Note: this is never used, but necessary to prevent a bug in Firefox\n// (https://bugzilla.mozilla.org/show_bug.cgi?id=1702191) where it collects\n// Web Workers that have a shared WebAssembly memory with the main thread,\n// but are not explicitly rooted via a `Worker` instance.\n//\n// By storing them in a variable, we can keep `Worker` objects around and\n// prevent them from getting GC-d.\nlet _workers;\n\nexport async function startWorkers(module, memory, builder) {\n  if (builder.numThreads() === 0) {\n    throw new Error(`num_threads must be > 0.`);\n  }\n\n  const workerInit = {\n    type: 'wasm_bindgen_worker_init',\n    init: { module_or_path: module, memory },\n    receiver: builder.receiver()\n  };\n\n  _workers = await Promise.all(\n    Array.from({ length: builder.numThreads() }, async () => {\n      // Self-spawn into a new Worker.\n      //\n      // TODO: while `new URL('...', import.meta.url) becomes a semi-standard\n      // way to get asset URLs relative to the module across various bundlers\n      // and browser, ideally we should switch to `import.meta.resolve`\n      // once it becomes a standard.\n      //\n      // Note: we could use `../../..` as the URL here to inline workerHelpers.js\n      // into the parent entry instead of creating another split point -\n      // this would be preferable from optimization perspective -\n      // however, Webpack then eliminates all message handler code\n      // because wasm-pack produces \"sideEffects\":false in package.json\n      // unconditionally.\n      //\n      // The only way to work around that is to have side effect code\n      // in an entry point such as Worker file itself.\n      const worker = new Worker(new URL('./workerHelpers.js', import.meta.url), {\n        type: 'module'\n      });\n      worker.postMessage(workerInit);\n      await waitForMsgType(worker, 'wasm_bindgen_worker_ready');\n      return worker;\n    })\n  );\n  builder.build();\n}\n"],"names":["waitForMsgType","target","type","resolve","onMsg","data","init","receiver","pkg","startWorkers","module","memory","builder","workerInit","worker"],"mappings":"AAoBA,SAASA,EAAeC,EAAQC,EAAM,CACpC,OAAO,IAAI,QAAQC,GAAW,CAC5BF,EAAO,iBAAiB,UAAW,SAASG,EAAM,CAAE,KAAAC,CAAI,EAAI,CACtDA,GAAM,OAASH,IACnBD,EAAO,oBAAoB,UAAWG,CAAK,EAC3CD,EAAQE,CAAI,EACd,CAAC,CACH,CAAC,CACH,CAEAL,EAAe,KAAM,0BAA0B,EAAE,KAAK,MAAO,CAAE,KAAAM,EAAM,SAAAC,KAAe,CAuBlF,MAAMC,EAAM,KAAM,QAAO,gCAAU,EACnC,MAAMA,EAAI,QAAQF,CAAI,EACtB,YAAY,CAAE,KAAM,4BAA6B,EACjDE,EAAI,uBAAuBD,CAAQ,CACrC,CAAC,EAWM,eAAeE,EAAaC,EAAQC,EAAQC,EAAS,CAC1D,GAAIA,EAAQ,WAAU,IAAO,EAC3B,MAAM,IAAI,MAAM,0BAA0B,EAG5C,MAAMC,EAAa,CACjB,KAAM,2BACN,KAAM,CAAE,eAAgBH,EAAQ,OAAAC,CAAM,EACtC,SAAUC,EAAQ,SAAQ,CAC9B,EAEa,MAAM,QAAQ,IACvB,MAAM,KAAK,CAAE,OAAQA,EAAQ,WAAU,CAAE,EAAI,SAAY,CAiBvD,MAAME,EAAS,IAAI,OAAO,KAAA,SAAA,KAAgD,CACxE,KAAM,QACd,CAAO,EACD,OAAAA,EAAO,YAAYD,CAAU,EAC7B,MAAMb,EAAec,EAAQ,2BAA2B,EACjDA,CACT,CAAC,CACL,EACEF,EAAQ,MAAK,CACf"}